'From Pharo7.0.4 of 13 August 2019 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)] on 21 February 2020 at 8:53:26.470219 pm'!RobotMind subclass: #MyTeamMind	instanceVariableNames: 'pathToHighestDensityPoint hasHighDensityAreas averageEnergy doesYellowSquareExist highestPointSquares depthNN depthDijkstra directionList statements warpCellEndpoints unreachablePoints unreachablePointsBackup'	classVariableNames: ''	poolDictionaries: ''	category: 'JRMPC-Phase1-Minds'!!MyTeamMind methodsFor: 'testing' stamp: 'BenTran 2/21/2020 12:03'!isTrapped: point Robot: sketchRobot Integer: count Set: squares    "comment stating purpose of message"    | x y neighbors|    x := point x.    y := point y.    "get the first neighbors arround the current point passed in as a parameter"    neighbors := self getFourNeighbors: x @ y Robot: sketchRobot.    (count = 0)ifTrue: [ ^ squares ]        ifFalse: [             1 to: neighbors size do: [ :neighborIndex |                | neighbor |                neighbor := neighbors at: neighborIndex.                (neighbor isMemberOf: DeathCell)                    ifFalse: [                         squares add: neighbor location.                        squares addAll:(self isTrapped: neighbor location Robot: sketchRobot Integer: count - 1 Set: squares).                                                ]                     ].                 ^ squares                 ]! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/21/2020 14:24'!determineDirectionForRobot: sketchRobot     "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.     This method is the main entrypoint for competition entries.     It is called each time the game world progresses one step in time.     'sketchRobot' is a copy of the map/robots as seen by a robot's scanners (i.e. no internal state).      Each time step provides a new independent scan 'sketchRobot'.     The mind instance remains constant across steps (i.e. it has memory across time steps).       The actual map/robots remain inaccessible to prevent accidental corruption of the game.    "	| point |	(averageEnergy = -123456)ifTrue: [ "this will only get called once when the robot is setup since the average point value is not known"		| highestDensityPoint densityOfPoint|		highestDensityPoint := self determineHighestDensityPoint: sketchRobot.		densityOfPoint := self determineDensityArroundPoint: highestDensityPoint Robot: sketchRobot. 		(densityOfPoint > (averageEnergy * 3))ifTrue: [ 			"self getDirectPathToPoint: highestDensityPoint  Robot: sketchRobot."			pathToHighestDensityPoint := self greedyPath: (sketchRobot location) Point: highestDensityPoint Robot: sketchRobot.			]		].			"this block of code checks to see if there s another high density point on the board that we can navigate to once we finish getting all the cells in the imediate vicinity"	((pathToHighestDensityPoint isEmpty) and: (directionList size = 1))ifTrue: [ 			| density highestDensityPoint |			density := self determineDensityArroundPoint: (sketchRobot location) Robot: sketchRobot.			(density < (averageEnergy))ifTrue: [ 				| densityOfPoint |				highestDensityPoint := self determineHighestDensityPoint: sketchRobot.				densityOfPoint := self determineDensityArroundPoint: highestDensityPoint Robot: sketchRobot. 				((densityOfPoint > (averageEnergy * 3) and: (density < (averageEnergy * 0.7))) or: (density < 0))ifTrue: [ 					"self getDirectPathToPoint: highestDensityPoint Robot: sketchRobot."					pathToHighestDensityPoint := (self greedyPath: ((directionList first at: 1)@(directionList first at: 2)) Point: highestDensityPoint Robot: sketchRobot).				 ]			]		 ].					(directionList isEmpty)ifTrue: [ 			(pathToHighestDensityPoint isEmpty)ifFalse: [ 				point := pathToHighestDensityPoint first.				pathToHighestDensityPoint removeAt: 1.			]ifTrue:[				self Dijkstra: sketchRobot. 				point := directionList first.				directionList removeAt: 1.				]		 ]ifFalse:[			point := directionList first.			directionList removeAt: 1.		].			direction := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). 	! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/7/2020 20:33'!direction	"COMPETITION ENTRIES _MUST_NOT_ OVERRIDE THIS METHOD	 This method is how the game later reads the mind's decision	"		"self assert: (direction isKindOf: RobotDirection)."	^ direction! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/21/2020 12:47'!setupOn: sketchRobot	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 This method facilitates initial setup of the mind related to the map parameters.	 It is called once by the competition framework when the mind is instantiated. 	 'sketchRobot' is a copy of the world as seen by the robot's scanners 	"				self determineWarpEndpoints: sketchRobot.	"Transcript crShow: (self greedyPath: sketchRobot location Point: 6@16 Robot: sketchRobot)."			! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/21/2020 12:49'!recoverOn: sketchRobot	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 If the mind doesn't complete its step within the designated time, its process is terminated.	 Depending on how you manage your data objects, they may end up corrupted.	 This method allows the mind to reset and continue playing. 	 'sketchRobot' is a copy of the world as seen by the robot's scanners 	"	Transcript crShow: 'PROGRAM TOOK TOO LONG, EXITING'.	self setupOn: sketchRobot! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/14/2020 16:57'!getDirectPathToPoint: point Robot: sketchRobot	| currentX currentY targetX targetY|		currentX := sketchRobot location x.		currentY := sketchRobot location y.		targetX := point x.		targetY := point y.		" add x vals to the path"		(targetX < currentX)ifTrue: [ 				currentX to: targetX by: -1 do: [:x|					pathToHighestDensityPoint addLast: (Array newFrom: {x . currentY})		 		]			 ]ifFalse:[			currentX to: targetX do: [:x|				pathToHighestDensityPoint addLast: (Array newFrom: {x . currentY})		 	]		].	" add y vals to the path"	(targetY < currentY)ifTrue: [ 			currentY to: targetY by: -1 do: [:y|				pathToHighestDensityPoint addLast: (Array newFrom: {targetX . y})		 	]		 ] ifFalse: [ 			currentY to: targetY do: [:y|				pathToHighestDensityPoint addLast: (Array newFrom: {targetX . y})		 	]		]! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/21/2020 14:20'!determineHighestDensityPoint: sketchRobot	| width height maxEnergy maxEnergyPoint totalEnergyOnGrid pointDensities highestDensityPointList|. "initilize the variable"   width := sketchRobot map width.   height := sketchRobot map height.	totalEnergyOnGrid := 0 .	maxEnergy := -10000000000. 	maxEnergyPoint := 1@1.	pointDensities := Dictionary new.	   1 to: height do:[:y | "assigns itterator number to y"        1 to: width do:[:x |			| totalEnergy |			totalEnergy := self determineDensityArroundPoint: x@y Robot: sketchRobot.			totalEnergyOnGrid := totalEnergyOnGrid + totalEnergy.			((sketchRobot map cellAt: x@y) isMemberOf: DeathCell)ifFalse:[					pointDensities at: totalEnergy put: x@y			]		]	].		averageEnergy := (totalEnergyOnGrid / ((width) * (height))) asInteger .	highestDensityPointList := ((pointDensities keys sorted) reversed).	1 to: (highestDensityPointList size) do: [ :i |		| density point path|		density := highestDensityPointList at: i.		point := pointDensities at: density.			((unreachablePoints includes: point) and: (unreachablePointsBackup includes: point))ifFalse:[		"(unreachablePoints includes: point)ifFalse:["			path := (self greedyPath: (sketchRobot location) Point: point Robot: sketchRobot).			(path isEmpty )ifFalse: [				maxEnergy := density.				(unreachablePoints includes: point)ifTrue:[					unreachablePoints remove: point.				].				(unreachablePointsBackup includes: point)ifTrue:[					unreachablePointsBackup remove: point.				].				maxEnergyPoint := point.				^maxEnergyPoint.				]ifTrue:[				"this implements a 'two strike' approach in order to determine if a point is actually unreachable and not just that we checkedd for that point within a deathbox"					(unreachablePoints includes: point)ifFalse:[						unreachablePoints add: point.					]ifTrue:[						(unreachablePointsBackup includes: point)ifFalse:[							"Transcript crShow: unreachablePoints.							Transcript crShow: unreachablePointsBackup."							unreachablePointsBackup add: point.							]						]				]		 ]	].						"(totalEnergy > maxEnergy)ifTrue: [ 					| path |										((sketchRobot map cellAt: x@y) isMemberOf: DeathCell)ifFalse:[						path := (self greedyPath: (sketchRobot location) Point: x@y Robot: sketchRobot).												(path isEmpty )ifFalse: [							maxEnergy := totalEnergy.							maxEnergyPoint := x@y				 		]				]			]"! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/21/2020 12:30'!determineDensityArroundPoint: point Robot: sketchRobot    | neighborQueue neighbors totalEnergy x y currentCell|.    x := point x.    y := point y.    totalEnergy := 0.    neighborQueue := OrderedCollection new.	currentCell := sketchRobot map cellAt: x@y.		"check if our central cell is either a death call or a warp cell"	(currentCell isMemberOf: WarpCell)ifTrue: [ 		x := currentCell target x.		y := currentCell target y.		totalEnergy := (sketchRobot map cellAt: (currentCell target)) energy. 		 ]ifFalse:[			(currentCell isMemberOf: DeathCell )ifTrue: [ 				^0.				 ]ifFalse:[				totalEnergy := currentCell energy.				]		].    "get the first neighbors arround the current point passed in as a parameter"    neighbors := self getFourNeighbors: x@y Robot: sketchRobot.    1 to: (neighbors size) do: [ : neighborIndex|        | neighbor neighborLocation|        neighbor := (neighbors at: neighborIndex).		  neighborLocation := neighbor location.        (neighborQueue includes: neighborLocation)ifFalse: [             (neighbor isMemberOf: DeathCell)ifFalse:[                neighborQueue addLast: neighborLocation.                	].				"(neighbor isMemberOf: WarpCell)ifTrue:[                neighborQueue addLast: (neighborLocation).                	]"                ]            ].    "get the second order neighbors arround those first points"    1 to: (neighborQueue size) do: [ : i|        neighbors := self getFourNeighbors: (neighborQueue at: i) Robot: sketchRobot.        1 to: (neighbors size) do: [ : neighborIndex|            | neighbor neighborLocation|        neighbor := (neighbors at: neighborIndex).		  neighborLocation := neighbor location.        (neighborQueue includes: neighborLocation)ifFalse: [             (neighbor isMemberOf: DeathCell)ifFalse:[                neighborQueue addLast: neighborLocation.                	].				"(neighbor isMemberOf: WarpCell)ifTrue: [                neighborQueue addLast: (neighborLocation).                	]"                ]            ]    ].    "once we have a list of all the neighbors arround the given point, sum up the point values for those neighbors"    1 to: (neighborQueue size) do: [ : i|        | neighbor |        neighbor := neighborQueue at: i.            totalEnergy := totalEnergy + ((sketchRobot map cellAt: neighbor) energy)        ].    ^totalEnergy.	! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/17/2020 23:02'!getFourNeighbors: point Robot: sketchRobot	| x y right down left up|	x := point x.	y := point y.	right := (sketchRobot map cellAt: (x+1)@y).	down := (sketchRobot map cellAt: x@(y-1)).	left := (sketchRobot map cellAt: (x-1)@y).	up := (sketchRobot map cellAt: x@(y+1)).		^(Array newFrom: {right . down . left . up})! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/18/2020 22:42'!Dijkstra: sketchRobot	"create a new list of all points within the robots scanning radius ----------------------------------------"	| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |	"Transcript crShow: 'Dijkstra HAS BEEN CALLED -----------------------------------------------------'."		scanningRadius := depthDijkstra.	grid := OrderedCollection new.	pointsList := OrderedCollection new.	x := sketchRobot location x.	y := sketchRobot location y.	1 to: scanningRadius * 2 + 1 do: [ :xCord | 		1 to: scanningRadius * 2 + 1 do: [ :yCord | 			| xPoint yPoint point |			xPoint := x - scanningRadius + xCord - 1.			yPoint := y - scanningRadius + yCord - 1.			"this will take a given coordinate and it wrap around the board"			point := self standardizePoint: xPoint Integer: yPoint	Integer: sketchRobot map width	Integer: sketchRobot map height.			(grid includes: point) ifFalse: [ "sometimes you get repeats because of the point standardization"					| pointValue pointObj|					grid addLast: point.					pointObj := (sketchRobot map cellAt: (point at: 1) @ (point at: 2)).					(pointObj isMemberOf: WarpCell)ifTrue: [ 							| maxNeighborEnergy warpCellNeighbors|							maxNeighborEnergy := 0.							warpCellNeighbors := self getFourNeighbors: (pointObj target) Robot: sketchRobot.							1 to: warpCellNeighbors size do: [ :index | 								(((warpCellNeighbors at: index) energy) > maxNeighborEnergy)ifTrue:[									maxNeighborEnergy := ((warpCellNeighbors at: index) energy)									]								].									pointValue := maxNeighborEnergy.					]ifFalse:[						pointValue := pointObj energy.					].				pointsList addLast: pointValue .			]		] 	].	"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"	"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"	highestPoint := pointsList max.	startingPoint := Array newFrom:{x . y}.	distanceFromStart := Dictionary new.	previousVertex := Dictionary new.	visited := OrderedCollection new.	unVisited := grid copy.	"Transcript crShow: 'STARTING POINT'.	Transcript show: startingPoint."		" set all distances to infinity and initlize previous distance dict with default keys"	1 to: grid size do: [ :i | 		| point |		point := grid at: i.		distanceFromStart at: point put: 1000000.	"1 million, number must be very large because distance from starting point to all other points is unkown at this point"		previousVertex at: point put: (Array newFrom: #(-1 -1)) ].	distanceFromStart at: startingPoint put: 0.			"point visit loop --------------------------------------------------------------------------------------------"	[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |			"find min value in distanceFromStart dict"			minValue := 10000000.	"10 million"			distanceFromStart	keysAndValuesDo: [ :key :value | 					((value < minValue) & ((visited includes: key) not))	ifTrue: [ 							currentPoint := key.							minValue := value 							]						 ].						"iterate through neighbors"			neighbors := self	getFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)	Robot: sketchRobot.			1 to: neighbors size do: [ :i | 				| neighbor neighborPoint |				neighbor := neighbors at: i.				neighborPoint := Array newFrom: {neighbor location x. neighbor location y}.				(grid includes: neighborPoint)ifTrue: [ | distance distanceFromNeighbor neighborEnergy|						(neighbor isMemberOf: DeathCell)ifTrue: [ 							neighborEnergy := -1000000.							 ]ifFalse:[								(neighbor isMemberOf: WarpCell)ifTrue: [ 									| maxNeighborEnergy warpCellNeighbors|									maxNeighborEnergy := 0.									warpCellNeighbors := self getFourNeighbors: (neighbor target) Robot: sketchRobot.									1 to: warpCellNeighbors size do: [ :index | 										(((warpCellNeighbors at: index) energy) > maxNeighborEnergy)ifTrue:[											maxNeighborEnergy := ((warpCellNeighbors at: index) energy)											]										].									neighborEnergy := maxNeighborEnergy.								]ifFalse:[									neighborEnergy := neighbor energy.								]							].						distance := (distanceFromStart at: currentPoint) + (highestPoint - neighborEnergy).						distanceFromNeighbor := distanceFromStart at: neighborPoint.						(distance < distanceFromNeighbor) ifTrue: [ 								distanceFromStart at: neighborPoint put: distance.								previousVertex at: neighborPoint put: currentPoint 								] 							] 						].			visited addLast: currentPoint.			unVisited remove: currentPoint 			].		"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"	shortestPathLength := 1000000.	"1 million"	bestPath := OrderedCollection new.	[ bestPath isEmpty ]		whileTrue: [ 1 to: grid size do: [ :i | 				| point |				point := grid at: i.				((distanceFromStart at: point) < shortestPathLength	& (point = startingPoint) not )ifTrue: [ "point is not equal to starting point"						| path newPoint shouldBreak |						path := OrderedCollection new.						"work backwards from best point to find optimal path"						path addLast: point.	"the point we are trying to is the first item since the list will be reversed"						newPoint := point.	"initialize newPoint w since this will be reassigned in the while loop"						shouldBreak := false.						[ shouldBreak ]whileFalse:[							 newPoint := previousVertex at: newPoint.	"get the previous point and add it to the list"								path addLast: newPoint.								newPoint = startingPoint									ifTrue: [ "if the starting point is equal to current point we found a path"										"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"										path size > scanningRadius											ifTrue: [ 												shortestPathLength := distanceFromStart at: point.												bestPath := path	"this best path is only truly the best once the while loop has exited" 													].										shouldBreak := true 										].								path size > (scanningRadius * 4)									ifTrue: [ shouldBreak := true 										] 									] 								] 							].			"Transcript crShow: 'could not find path'."			scanningRadius := scanningRadius - 1 			].	bestPath removeLast.	bestPath := bestPath reversed.	directionList := bestPath! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/21/2020 14:03'!greedyPath: startPoint Point: endPoint Robot: sketchRobot    "comment stating purpose of message"    | priority neighbors current cameFrom path |        priority := Dictionary new.    cameFrom := Dictionary new.    path := OrderedCollection new.        cameFrom at: startPoint put: -1000.    priority at: startPoint put: 0.    [(priority size > 0) and: ((priority size) < ((sketchRobot map width) * 1.5) asInteger)]whileTrue:[        | minValue |        minValue := priority values min.        priority keysAndValuesDo:[ :key :value |            (value = minValue)ifTrue:[                current := key ].            ].                priority removeKey: current.                (current = endPoint)ifTrue:[            [current = -1000]whileFalse:[                path add: (Array newFrom: {current x . current y}).                current := cameFrom at: current                ].				path removeLast.            path := path reversed.            ^path.]            ifFalse:[            neighbors := self getFourNeighbors: current Robot: sketchRobot.            1 to: neighbors size do: [ :neighborIndex |                | neighbor |                neighbor := neighbors at: neighborIndex.                         (neighbor isMemberOf: DeathCell)ifFalse: [                     ((cameFrom keys) includes: (neighbor location))ifFalse:[                            (neighbor energy <= -100000)ifTrue:[                        priority at: (neighbor location) put: (2*((neighbor location x - endPoint x) abs + (neighbor location y - endPoint y) abs)).                        cameFrom at: (neighbor location) put: current.								] ifFalse:[                               priority at: (neighbor location) put: (((neighbor location x - endPoint x) abs + (neighbor location y - endPoint y) abs)).                        			cameFrom at: (neighbor location) put: current].].        ].].].].	^(OrderedCollection new) ! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/16/2020 22:37'!determineWarpEndpoints: sketchRobot	| width height |. "initilize the variable"   width := sketchRobot map width.   height := sketchRobot map height.	   1 to: height do:[:y | "assigns itterator number to y"        1 to: width do:[:x |			| cell |			cell := (sketchRobot map cellAt: x@y).			(cell isMemberOf: WarpCell)ifTrue: [ 				| endpoint |				endpoint := cell target.				warpCellEndpoints at: (cell location) put: endpoint.				 ]		]	].! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:34'!standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows	"this will take a given coordinate and it wrap around the board"	| newXPoint newYPoint |.		newXPoint := ((xPoint \\ columns) abs). "\\ is the same as % in python, coordinate system starts at 1,1 so we need to shift everything by 1"	newYPoint := ((yPoint \\ rows) abs).		(xPoint = 0)ifTrue: [ 		newXPoint := columns 		 ].	(newXPoint = 0)ifTrue: [ 		newXPoint := columns 		 ].	(yPoint = 0)ifTrue: [ 		newYPoint := rows 		 ].	(newYPoint = 0)ifTrue: [ 		newYPoint := rows 		 ].		^ Array newFrom: {newXPoint . newYPoint}.		! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/21/2020 14:28'!DetermineRobotMovementFromPoint: point Robot: sketchRobot	| fourNeighbors directionDict|	fourNeighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"	directionDict := Dictionary newFrom: {1 -> RobotEast soleInstance . 2 -> RobotSouth soleInstance . 3 -> RobotWest soleInstance . 4 -> RobotNorth soleInstance .}.	1 to: 4 do: [ 				: neighborIndex|				|neighbor neighborPoint|.				neighbor := (fourNeighbors at: neighborIndex). 				neighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.				(neighborPoint = point)ifTrue: [ 					^(directionDict at: neighborIndex)				].	].	"if the program gets here it most likley means that we have either warped or jumped since the path will not be out of bounds of the current robot point"	directionList := OrderedCollection new.	pathToHighestDensityPoint := OrderedCollection new.	! !!MyTeamMind methodsFor: 'initialization' stamp: 'BenTran 2/21/2020 13:39'!initialize 	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 This method is not part of the competition API, but a standard part of Pharo	 called when objects are instatiated."	doesYellowSquareExist := false.	highestPointSquares := OrderedCollection new. 	pathToHighestDensityPoint := OrderedCollection new.	unreachablePoints := Set new.	unreachablePointsBackup := Set new.	hasHighDensityAreas := true.	averageEnergy := -123456.	depthNN := 3. "number of layers deep that the NN should look at"	depthDijkstra := 4.	directionList := OrderedCollection new.	warpCellEndpoints := Dictionary new.	super initialize! !