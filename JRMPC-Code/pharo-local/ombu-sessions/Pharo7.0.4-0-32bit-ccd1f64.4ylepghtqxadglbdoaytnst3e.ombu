OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T11:35:05.84013-05:00' ],		#prior : OmReference [ 'Pharo7.0.4-0-32bit-ccd1f64.fpeycdl3nkyurlq2mnupray6', '4' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:Robot:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: scanningRadius Robot: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: point\r\t\t\t\t ].\r\t\t ].\r\t].\r\t',			#stamp : 'BenTran 2/6/2020 10:13',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:Robot:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: scanningRadius Robot: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t\r\t\t\r\t\t\r\t\t ]\r\t\r\t\r\t\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 11:35',			#package : #JRMPC-Phase1-Minds		}	}}