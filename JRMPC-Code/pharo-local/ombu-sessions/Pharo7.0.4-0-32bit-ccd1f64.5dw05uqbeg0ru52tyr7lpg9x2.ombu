OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T10:46:44.26319-05:00' ],		#prior : OmReference [ 'Pharo7.0.4-0-32bit-ccd1f64.f43emicfuw3qamgi4sygyzt2n', '26' ],		#self : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T10:46:44.28419-05:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T10:46:44.30519-05:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T10:46:44.32519-05:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T10:46:44.34419-05:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T10:46:44.38419-05:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @27				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @27			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @27,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T10:46:44.43819-05:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\n\tsuper initialize',			#stamp : 'BenTran 1/29/2020 16:17',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 7. "number of layers deep that the NN should look at"\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 10:46',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T10:56:56.06719-05:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#protocol : #abstract	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T10:57:00.89419-05:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#protocol : #abstract	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:31:42.27419-05:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'setupOn:',			#protocol : #running,			#sourceCode : 'setupOn: sketchRobot\r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method facilitates initial setup of the mind related to the map parameters.\r\n\t It is called once by the competition framework when the mind is instantiated.\r\n \t \'sketchRobot\' is a copy of the world as seen by the robot\'s scanners \r\n\t"\r\t"chekc for yellow square"\r\t|width height itterator|. "initilize the variable"\r   width := sketchRobot map width.\r   height := sketchRobot map height.\r\titterator := 1.\r   1 to: height do:[ "for loop"\r   \t\t:y | "assigns itterator number to i" \r       1 to: width do:[\r       \t:x |\r\t\t\t|energyValue|.\r\t\t\tenergyValue := ((sketchRobot map cellAt: x@y) energy).\r         (energyValue> 90) "the x@y signifies a point object ex: (1,1) or (5,99)"\r         ifTrue: [ \r         \thighestPointSquares add: energyValue.\r\t\t\titterator := itterator + 1.\r         \tdoesYellowSquareExist := true.\r         ].\r\t\t].\r\t].\r\tTranscript show: (highestPointSquares sorted).\r\n',			#stamp : 'BenTran 1/29/2020 16:19',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'setupOn:',			#protocol : #running,			#sourceCode : 'setupOn: sketchRobot\r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method facilitates initial setup of the mind related to the map parameters.\r\n\t It is called once by the competition framework when the mind is instantiated.\r\n \t \'sketchRobot\' is a copy of the world as seen by the robot\'s scanners \r\n\t"\r\t"chekc for yellow square"\r\t|width height itterator|. "initilize the variable"\r   width := sketchRobot map width.\r   height := sketchRobot map height.\r\titterator := 1.\r   1 to: height do:[ "for loop"\r   \t\t:y | "assigns itterator number to i" \r       1 to: width do:[\r       \t:x |\r\t\t\t|energyValue|.\r\t\t\tenergyValue := ((sketchRobot map cellAt: x@y) energy).\r         (energyValue> 90) "the x@y signifies a point object ex: (1,1) or (5,99)"\r         ifTrue: [ \r         \thighestPointSquares add: energyValue.\r\t\t\titterator := itterator + 1.\r         \tdoesYellowSquareExist := true.\r         ].\r\t\t].\r\t].\r\tTranscript show: (highestPointSquares sorted).\r\t\r\t\r\t\r\n',			#stamp : 'BenTran 1/31/2020 11:31',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:31:47.81819-05:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot\r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\tdirection := RobotEast soleInstance. ',			#stamp : 'BenTran 1/29/2020 16:11',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot\r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\tsketchRobot moveLeft.',			#stamp : 'BenTran 1/31/2020 11:31',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:46.68719-05:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:46.70919-05:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:46.73019-05:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:46.75219-05:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:46.80319-05:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:46.82619-05:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @29				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @29			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @29,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:48.17719-05:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:48.19919-05:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:48.22019-05:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:48.24019-05:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:48.29119-05:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:48.31219-05:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @31				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @31				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @31				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @31				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @31				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @31				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @31			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @31,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:48.32619-05:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 7. "number of layers deep that the NN should look at"\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 10:46',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 7. "number of layers deep that the NN should look at"\r\tcurrentX = 0.\r\tcurrentY := 0.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 11:32',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:32:59.63519-05:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 7. "number of layers deep that the NN should look at"\r\tcurrentX = 0.\r\tcurrentY := 0.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 11:32',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 7. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 11:32',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:40:04.70719-05:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t| currentItterations x y paths|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpaths := Dictionary newFrom: {0 -> OrderedCollection new.}.\r\tpaths at: 0 at: 0 put: (Array newFrom: #(x y)). "puts an array within the ordered collection adfined above"\r\tTranscript crShow: paths.\r\t\r\t',			#stamp : 'BenTran 1/31/2020 11:40',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T11:42:42.32919-05:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot\r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\tsketchRobot moveLeft.',			#stamp : 'BenTran 1/31/2020 11:31',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot\r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\tdirection := RobotEast soleInstance. ',			#stamp : 'BenTran 1/31/2020 11:42',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:09:58.66519-05:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot\r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\tdirection := RobotEast soleInstance. ',			#stamp : 'BenTran 1/31/2020 11:42',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot\r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\tdirection := RobotEast soleInstance. \r\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\tTranscript crShow: \'CALLED PLOTPATHFORNN\'',			#stamp : 'BenTran 1/31/2020 12:09',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:11:54.09219-05:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t| currentItterations x y paths|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpaths := Dictionary newFrom: {0 -> OrderedCollection new.}.\r\tpaths at: 0 at: 0 put: (Array newFrom: #(x y)). "puts an array within the ordered collection adfined above"\r\tTranscript crShow: paths.\r\t\r\t',			#stamp : 'BenTran 1/31/2020 11:40',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t| currentItterations x y paths|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpaths := Dictionary newFrom: {0 -> OrderedCollection new.}.\r\tpaths at: 0 add: (Array newFrom: #(x y)). "puts an array within the ordered collection adfined above"\r\tTranscript crShow: paths.\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:11',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:15:32.02419-05:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t| currentItterations x y paths|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpaths := Dictionary newFrom: {0 -> OrderedCollection new.}.\r\tpaths at: 0 add: (Array newFrom: #(x y)). "puts an array within the ordered collection adfined above"\r\tTranscript crShow: paths.\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:11',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t| currentItterations x y paths|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpaths := Dictionary newFrom: {0 -> OrderedCollection new.}.\r\tTranscript crShow: (paths at: 0).\r\tpaths at: 0 put: ((paths at: 0) add: (Array newFrom: #(x y))). "puts an array within the ordered collection adfined above"\r\tTranscript crShow: paths.\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:15',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:24:54.28219-05:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t| currentItterations x y paths|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpaths := Dictionary newFrom: {0 -> OrderedCollection new.}.\r\tTranscript crShow: (paths at: 0).\r\tpaths at: 0 put: ((paths at: 0) add: (Array newFrom: #(x y))). "puts an array within the ordered collection adfined above"\r\tTranscript crShow: paths.\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:15',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t| currentItterations x y paths|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\t\r\tpaths := Dictionary newFrom: {0 -> [ |collection| \r\t\tcollection := OrderedCollection new.\r\t\tcollection add: (Array newFrom: #(x y)).\r\t\t^collection\r\t\t].\r\t}.\r\tTranscript crShow: paths.\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:24',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:28:10.26119-05:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t| currentItterations x y paths|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\t\r\tpaths := Dictionary newFrom: {0 -> [ |collection| \r\t\tcollection := OrderedCollection new.\r\t\tcollection add: (Array newFrom: #(x y)).\r\t\t^collection\r\t\t].\r\t}.\r\tTranscript crShow: paths.\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:24',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t| currentItterations x y paths firstPath|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\t\r\tpaths := Dictionary newFrom: {0 -> firstPath.}. "paths = {0:[(x, y)]} in python"\r\tTranscript crShow: paths.\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:28',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:32:14.99119-05:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t| currentItterations x y paths firstPath|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\t\r\tpaths := Dictionary newFrom: {0 -> firstPath.}. "paths = {0:[(x, y)]} in python"\r\tTranscript crShow: paths.\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:28',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 0.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {0 -> firstPath.}. \r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:32',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:42:57.40119-05:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 0.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {0 -> firstPath.}. \r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:32',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 34-> firstPath.}. \r\t\r\t(currentItterations <= depthNN) whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) length) do: [ \r\t\t\t:key|\r\t\t\t|value|\r\t\t\tvalue := paths at: key.\r\t\t\tTranscript crShow: value.\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:42',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:44:01.29919-05:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 34-> firstPath.}. \r\t\r\t(currentItterations <= depthNN) whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) length) do: [ \r\t\t\t:key|\r\t\t\t|value|\r\t\t\tvalue := paths at: key.\r\t\t\tTranscript crShow: value.\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:42',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 34-> firstPath.}. \r\t\r\t(currentItterations <= depthNN) whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) length) do: [ \r\t\t\t:key|\r\t\t\t|value|\r\t\t\tvalue := paths at: key.\r\t\t\tTranscript crShow: value.\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:44',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:44:32.07419-05:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 34-> firstPath.}. \r\t\r\t(currentItterations <= depthNN) whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) length) do: [ \r\t\t\t:key|\r\t\t\t|value|\r\t\t\tvalue := paths at: key.\r\t\t\tTranscript crShow: value.\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:44',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t(currentItterations <= depthNN) whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) length) do: [ \r\t\t\t:key|\r\t\t\t|value|\r\t\t\tvalue := paths at: key.\r\t\t\tTranscript crShow: value.\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:44',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:45:12.79819-05:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t(currentItterations <= depthNN) whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) length) do: [ \r\t\t\t:key|\r\t\t\t|value|\r\t\t\tvalue := paths at: key.\r\t\t\tTranscript crShow: value.\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:44',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) length) do: [ \r\t\t\t:key|\r\t\t\t|value|\r\t\t\tvalue := paths at: key.\r\t\t\tTranscript crShow: value.\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:45',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:47:54.77819-05:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) length) do: [ \r\t\t\t:key|\r\t\t\t|value|\r\t\t\tvalue := paths at: key.\r\t\t\tTranscript crShow: value.\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:45',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|value|\r\t\t\tvalue := paths at: key.\r\t\t\tTranscript crShow: value.\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:47',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T12:58:25.71919-05:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|value|\r\t\t\tvalue := paths at: key.\r\t\t\tTranscript crShow: value.\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:47',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors.\r\t\t\tTranscript crShow: neighbors.  \r\t\t\t\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:58',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:01:51.87619-05:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors.\r\t\t\tTranscript crShow: neighbors.  \r\t\t\t\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 12:58',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors.\r\t\t\tTranscript crShow: sketchRobot location.\r\t\t\tTranscript crShow: neighbors.  \r\t\t\t\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:01',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:10:32.08019-05:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors.\r\t\t\tTranscript crShow: sketchRobot location.\r\t\t\tTranscript crShow: neighbors.  \r\t\t\t\r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:01',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor = neighbors at: neighborIndex. \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:10',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:12:02.45419-05:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor = neighbors at: neighborIndex. \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:10',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor = neighbors at: neighborIndex. \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:12',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:12:29.53419-05:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor = neighbors at: neighborIndex. \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:12',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|\r\t\t\t\tneighbor = neighbors at: neighborIndex. \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:12',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:12:39.67219-05:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|\r\t\t\t\tneighbor = neighbors at: neighborIndex. \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:12',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor = neighbors at: neighborIndex. \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:12',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:15:05.91419-05:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor = neighbors at: neighborIndex. \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:12',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:15',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:20:04.67219-05:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(x y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:15',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(#x #y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:20',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:24:18.34219-05:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: #(#x #y)).\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:20',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x asInteger y asInteger}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:24',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:24:53.99719-05:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x asInteger y asInteger}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:24',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:24',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:29:09.83019-05:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := currentX.\r\ty := currentY.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'HERE\'.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:24',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript show: x.\r\tTranscript show: \' \'.\r\tTranscript show: y.\r\tTranscript crShow: \'HERE\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:29',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:30:45.85719-05:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript show: x.\r\tTranscript show: \' \'.\r\tTranscript show: y.\r\tTranscript crShow: \'HERE\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:29',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: sketchRobot location x. \r\tTranscript show: x.\r\tTranscript show: \' \'.\r\tTranscript show: y.\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:30',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:31:57.43619-05:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: sketchRobot location x. \r\tTranscript show: x.\r\tTranscript show: \' \'.\r\tTranscript show: y.\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:30',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: sketchRobot location x. \r\t"Transcript show: x.\r\tTranscript show: \' \'.\r\tTranscript show: y."\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:31',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:32:46.46319-05:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: sketchRobot location x. \r\t"Transcript show: x.\r\tTranscript show: \' \'.\r\tTranscript show: y."\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:31',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: x.\r\tTranscript crShow: y.\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:32',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:35:45.98919-05:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: x.\r\tTranscript crShow: y.\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:32',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: x class.\r\tTranscript crShow: y class.\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:35',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:38:26.18519-05:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: x class.\r\tTranscript crShow: y class.\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:35',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: x class.\r\tTranscript crShow: y class.\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:38',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:38:46.15019-05:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: x class.\r\tTranscript crShow: y class.\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:38',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: x class.\r\tTranscript crShow: y class.\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:38',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:42:56.55019-05:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tTranscript crShow: x class.\r\tTranscript crShow: y class.\r\tTranscript crShow: \'HERE123\'.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: neighbors. \r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: path.\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:38',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: neighbor. \r\t\t\t\t"((neighbor at: 1) = (neighbor at: 2))ifTrue:"\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:42',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:43:33.86419-05:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: neighbor. \r\t\t\t\t"((neighbor at: 1) = (neighbor at: 2))ifTrue:"\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:42',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: neighbor class. \r\t\t\t\t"((neighbor at: 1) = (neighbor at: 2))ifTrue:"\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:43',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:47:40.90419-05:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: neighbor class. \r\t\t\t\t"((neighbor at: 1) = (neighbor at: 2))ifTrue:"\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:43',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: neighbor location. \r\t\t\t\t"((neighbor at: 1) = (neighbor at: 2))ifTrue:"\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:47',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:54:43.28819-05:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: neighbor location. \r\t\t\t\t"((neighbor at: 1) = (neighbor at: 2))ifTrue:"\r\t\t\t\t\r\t\t\t\t\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:47',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: neighbor location. \r\t\t\t\tTranscript crShow: path.\r\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifFalse:[\r\t\t\t\t\t Transcript crShow: \'DOES NOT INCLUDE\'.\r\t\t\t\t\t\r\t\t\t\t\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:54',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:58:19.46419-05:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tTranscript crShow: neighbor location. \r\t\t\t\tTranscript crShow: path.\r\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifFalse:[\r\t\t\t\t\t Transcript crShow: \'DOES NOT INCLUDE\'.\r\t\t\t\t\t\r\t\t\t\t\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:54',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\t\r\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifTrue: [\r\t\t\t\t\t \r\t\t\t\t\t\r\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tTranscript crShow: neighbor location. \r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:58',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:59:12.12019-05:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\t\r\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifTrue: [\r\t\t\t\t\t \r\t\t\t\t\t\r\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tTranscript crShow: neighbor location. \r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:58',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\t\r\t\t\t\t\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifTrue: [\r\t\t\t\t\t \r\t\t\t\t\t\r\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:59',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T13:59:50.29919-05:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\t\r\t\t\t\t\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifTrue: [\r\t\t\t\t\t \r\t\t\t\t\t\r\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:59',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\t\r\t\t\t\t\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifTrue: [\r\t\t\t\t\t \r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t\r\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:59',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T14:05:33.61219-05:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\t\r\t\t\t\t\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifTrue: [\r\t\t\t\t\t \r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t\r\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 13:59',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\t\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifFalse: [\r\t\t\t\t\t |newVal|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tTranscript crShow: newVal .\r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 14:05',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T14:06:03.37219-05:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {0 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\t\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifFalse: [\r\t\t\t\t\t |newVal|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tTranscript crShow: newVal .\r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 14:05',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\t\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifFalse: [\r\t\t\t\t\t |newVal|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tTranscript crShow: newVal .\r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 14:06',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T14:11:53.08419-05:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\t\r\t\t\t\t(path includes: (Array newFrom: {(neighbor location x) . (neighbor location y)}))ifFalse: [\r\t\t\t\t\t |newVal|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tTranscript crShow: newVal .\r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 14:06',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 14:11',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:10:57.46019-05:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\t ].\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 14:11',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations  = currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:10',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:11:40.69919-05:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations  = currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:10',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:11',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:13:35.18519-05:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:11',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tTranscript crShow: paths.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:13',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:14:17.40919-05:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tTranscript crShow: paths.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'.\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:13',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tTranscript crShow: paths.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:14',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:28:40.92819-05:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t1 to: ((paths values) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tTranscript crShow: paths.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:14',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tTranscript crShow: paths.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:28',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:35:33.98419-05:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tTranscript crShow: paths.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:28',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: paths.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tTranscript crShow: paths.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:35',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:46:38.86319-05:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 7. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 11:32',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 4. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 22:46',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:46:43.00619-05:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: paths.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\r\t\t\tTranscript crShow: paths.\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:35',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:46',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:51:27.75419-05:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestJRMPCPhaseMinds\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'PackageManifest'			},			#name : #ManifestJRMPCPhaseMinds,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestJRMPCPhaseMinds class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestJRMPCPhaseMinds class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestJRMPCPhaseMinds,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:51:27.75819-05:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpCategoryAddition {		#classCategoryName : #JRMPC-Phase1-Minds-Manifest,		#affectedPackageName : #JRMPC-Phase1-Minds	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:51:27.76219-05:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #JRMPC-Phase1-Minds,		#newCategory : #JRMPC-Phase1-Minds-Manifest,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestJRMPCPhaseMinds\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds-Manifest\'',				#superclassName : 'PackageManifest'			},			#name : #ManifestJRMPCPhaseMinds,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestJRMPCPhaseMinds class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestJRMPCPhaseMinds class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestJRMPCPhaseMinds,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds-Manifest,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:51:27.76719-05:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestJRMPCPhaseMinds\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds-Manifest\'',				#superclassName : 'PackageManifest'			},			#name : #ManifestJRMPCPhaseMinds,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestJRMPCPhaseMinds class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestJRMPCPhaseMinds class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestJRMPCPhaseMinds,					#isMetaSide : false				},				#parent : @7,				#content : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds-Manifest,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:51:27.77619-05:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBWhileTrueRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBWhileTrueRuleV1FalsePositive\r\t^ #()',			#stamp : 'BenTran 1/31/2020 22:51',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:51:27.78519-05:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBWhileTrueRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBWhileTrueRuleV1FalsePositive\r\t^ #()',			#stamp : 'BenTran 1/31/2020 22:51',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBWhileTrueRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBWhileTrueRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#RobotMind #plotPathForNN: #false)) #\'2020-01-31T22:51:27.77819-05:00\') )',			#stamp : 'BenTran 1/31/2020 22:51',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:51:38.18519-05:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBWhileTrueRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBWhileTrueRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#RobotMind #plotPathForNN: #false)) #\'2020-01-31T22:51:27.77819-05:00\') )',			#stamp : 'BenTran 1/31/2020 22:51',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBWhileTrueRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBWhileTrueRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#RobotMind #plotPathForNN: #false)) #\'2020-01-31T22:51:27.77819-05:00\') #(#(#RGClassDefinition #(#RobotMind)) #\'2020-01-31T22:51:38.16819-05:00\') )',			#stamp : 'BenTran 1/31/2020 22:51',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:51:44.02819-05:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBToDoRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBToDoRuleV1FalsePositive\r\t^ #()',			#stamp : 'BenTran 1/31/2020 22:51',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:51:44.03619-05:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBToDoRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBToDoRuleV1FalsePositive\r\t^ #()',			#stamp : 'BenTran 1/31/2020 22:51',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBToDoRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBToDoRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#RobotMind #plotPathForNN: #false)) #\'2020-01-31T22:51:44.02919-05:00\') )',			#stamp : 'BenTran 1/31/2020 22:51',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:52:59.98619-05:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:46',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:52',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:55:19.72619-05:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:52',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\tTranscript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:55',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:58:19.15119-05:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\tTranscript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:55',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:58',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T22:59:40.24219-05:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 4. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 22:46',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 7. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 22:59',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:01:07.03419-05:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 22:58',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:01',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:02:08.65519-05:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:01',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:02',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:03:59.38519-05:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:02',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\tTranscript crShow: ((paths keys) at: 1).\r\t\tTranscript crShow: ((paths keys) size).\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:03',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:05:53.29219-05:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\tTranscript crShow: ((paths keys) at: 1).\r\t\tTranscript crShow: ((paths keys) size).\r\t\t((paths keys) at: 1) to: ((paths keys) size) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:03',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\tTranscript crShow: ((paths keys) at: 1).\r\t\tTranscript crShow: ((paths keys) size).\r\t\t((paths keys) first) to: ((paths keys) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:05',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:06:03.56519-05:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\tTranscript crShow: ((paths keys) at: 1).\r\t\tTranscript crShow: ((paths keys) size).\r\t\t((paths keys) first) to: ((paths keys) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:05',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\tTranscript crShow: ((paths keys) first).\r\t\tTranscript crShow: ((paths keys) last).\r\t\t((paths keys) first) to: ((paths keys) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:06',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:08:19.38119-05:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\tTranscript crShow: ((paths keys) first).\r\t\tTranscript crShow: ((paths keys) last).\r\t\t((paths keys) first) to: ((paths keys) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:06',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\tTranscript crShow: ((paths keys) first).\r\t\tTranscript crShow: ((paths keys) last).\r\t\tTranscript crShow: (paths keys).\r\t\t((paths keys) first) to: ((paths keys) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:08',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:10:27.78819-05:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\tTranscript crShow: ((paths keys) first).\r\t\tTranscript crShow: ((paths keys) last).\r\t\tTranscript crShow: (paths keys).\r\t\t((paths keys) first) to: ((paths keys) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:08',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\tTranscript crShow: ((paths keys sorted) first).\r\t\tTranscript crShow: ((paths keys sorted) last).\r\t\tTranscript crShow: (paths keys sorted).\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:10',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:13:21.50519-05:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\tTranscript crShow: ((paths keys sorted) first).\r\t\tTranscript crShow: ((paths keys sorted) last).\r\t\tTranscript crShow: (paths keys sorted).\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:10',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\tTranscript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:13',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:17:48.70519-05:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tTranscript crShow: \'here2\'.\t\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\tTranscript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:13',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\tTranscript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:17',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:21:40.67319-05:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\tTranscript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tTranscript crShow: paths.\r\t\tpaths := newPaths copy.\r\t\tTranscript crShow: paths.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\tTranscript crShow: pathEnergies values.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:17',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:21',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:22:54.81119-05:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\tTranscript crShow: \'here1\'.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tTranscript crShow: \'here3\'.\t\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:21',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:22',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:26:01.15819-05:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath. 2 -> firstPath. 3 -> firstPath. 4-> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:22',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:26',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:31:31.77119-05:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:26',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: 0@0 fourNeighbors.\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:31',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:32:00.88619-05:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\tTranscript crShow: 0@0 fourNeighbors.\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:31',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:32',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:39:03.48519-05:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'getFourNeighbors:Robot:',			#protocol : #'as yet unclassified',			#sourceCode : 'getFourNeighbors: point Robot: sketchRobot\r\t| x y right down left up|\r\tx := point location x.\r\ty := point location y.\r\tright := (sketchRobot map cellAt: (x+1)@y).\r\tdown := (sketchRobot map cellAt: x@(y-1)).\r\tleft := (sketchRobot map cellAt: (x-1)@y).\r\tup := (sketchRobot map cellAt: x@(y+1)).\r\t\r\t^(Array newFrom: {right . down . left . up})\r\t',			#stamp : 'BenTran 1/31/2020 23:39',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:42:06.51519-05:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tneighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:32',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tTranscript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot).\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:42',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:42:18.48319-05:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot\r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\tdirection := RobotEast soleInstance. \r\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\tTranscript crShow: \'CALLED PLOTPATHFORNN\'',			#stamp : 'BenTran 1/31/2020 12:09',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot\r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\tdirection := RobotEast soleInstance. \r\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" ',			#stamp : 'BenTran 1/31/2020 23:42',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:43:15.59319-05:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'getFourNeighbors:Robot:',			#protocol : #'as yet unclassified',			#sourceCode : 'getFourNeighbors: point Robot: sketchRobot\r\t| x y right down left up|\r\tx := point location x.\r\ty := point location y.\r\tright := (sketchRobot map cellAt: (x+1)@y).\r\tdown := (sketchRobot map cellAt: x@(y-1)).\r\tleft := (sketchRobot map cellAt: (x-1)@y).\r\tup := (sketchRobot map cellAt: x@(y+1)).\r\t\r\t^(Array newFrom: {right . down . left . up})\r\t',			#stamp : 'BenTran 1/31/2020 23:39',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'getFourNeighbors:Robot:',			#protocol : #'as yet unclassified',			#sourceCode : 'getFourNeighbors: point Robot: sketchRobot\r\t| x y right down left up|\r\tx := point x.\r\ty := point y.\r\tright := (sketchRobot map cellAt: (x+1)@y).\r\tdown := (sketchRobot map cellAt: x@(y-1)).\r\tleft := (sketchRobot map cellAt: (x-1)@y).\r\tup := (sketchRobot map cellAt: x@(y+1)).\r\t\r\t^(Array newFrom: {right . down . left . up})\r\t',			#stamp : 'BenTran 1/31/2020 23:43',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:44:08.05319-05:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\tTranscript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot).\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:42',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\t"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:44',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:45:05.85719-05:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\t"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:44',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\t"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: \'HERE\'.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:45',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:45:48.93319-05:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 7. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 22:59',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 4. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 23:45',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:46:26.48319-05:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\t"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath remove: 1.\r\tTranscript crShow: \'HERE\'.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:45',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\t"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tTranscript crShow: \'HERE\'.\r\tTranscript crShow: bestPath.\r\tbestPath remove: 1.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:46',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:49:52.22019-05:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\t"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tTranscript crShow: \'HERE\'.\r\tTranscript crShow: bestPath.\r\tbestPath remove: 1.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:46',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\t"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tTranscript crShow: \'HERE\'.\r\tTranscript crShow: bestPath.\r\tbestPath removeAt: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:49',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:50:36.27119-05:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\t"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tTranscript crShow: \'HERE\'.\r\tTranscript crShow: bestPath.\r\tbestPath removeAt: 1\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:49',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\t"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tTranscript crShow: \'HERE\'.\r\tTranscript crShow: bestPath.\r\tbestPath removeAt: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:50',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:52:40.17019-05:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:52:40.19619-05:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:52:40.22419-05:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:52:40.24819-05:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:52:40.27219-05:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:52:40.31519-05:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY directionList\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @33				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @33				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @33				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @33				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @33				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @33				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #directionList,					#parent : @33				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @33,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-01-31T23:52:40.41219-05:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 4. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 23:45',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 4. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 23:52',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-01T00:03:26.63219-05:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'DetermineRobotMovementFromPoint:Robot:',			#protocol : #'as yet unclassified',			#sourceCode : 'DetermineRobotMovementFromPoint: point Robot: sketchRobot\r\t| fourNeighbors directionDict|\r\tfourNeighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\tdirectionDict := Dictionary newFrom: {1 -> RobotWest soleInstance . 2 -> RobotSouth soleInstance . 3 -> RobotEast soleInstance . 4 -> RobotNorth soleInstance .}.\r\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (fourNeighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(neighborPoint = point)ifTrue: [ \r\t\t\t\t\t^(directionDict at: neighborIndex)\r\t\t\t\t].\r\t].\r\t',			#stamp : 'BenTran 2/1/2020 00:03',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-01T00:05:23.10119-05:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot\r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\tdirection := RobotEast soleInstance. \r\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" ',			#stamp : 'BenTran 1/31/2020 23:42',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList size = 0)ifTrue: [ \r\t\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\t\r\tpoint := directionList first.\r\tdirection := self DetermineRobotMovementFromPoint: point Robot: sketchRobot. \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/1/2020 00:05',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-01T00:05:36.15019-05:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\t"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tTranscript crShow: \'HERE\'.\r\tTranscript crShow: bestPath.\r\tbestPath removeAt: 1.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 1/31/2020 23:50',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'plotPathForNN:',			#protocol : #'as yet unclassified',			#sourceCode : 'plotPathForNN: sketchRobot\r\t"variable initilization"\r\t| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|\r\tcurrentItterations := 1.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\tpathID := 1.\r\tpathEnergies := Dictionary newFrom: {1 -> 0.}.\r\t\r\t"paths = {0:[(x, y)]} in python"\r\tfirstPath := OrderedCollection new.\r\tfirstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"\r\tpaths := Dictionary newFrom: {1 -> firstPath.}. \r\t\r\t[currentItterations <= depthNN] whileTrue: [ \r\t\t|newPaths|.\r\t\tnewPaths := Dictionary new.\r\t\t((paths keys sorted) first) to: ((paths keys sorted) last) do: [ \r\t\t\t:key|\r\t\t\t|path neighbors|.\t\r\t\t\tpath := paths at: key.\r\t\t\t"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."\r\t\t\tneighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"\r\t\t\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (neighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t"Transcript crShow: path.\r\t\t\t\tTranscript crShow: neighborPoint.\t"\t\r\t\t\t\t(path includes: neighborPoint )ifFalse: [\r\t\t\t\t\t |newVal newPath|.\r\t\t\t\t\tnewVal := (pathEnergies at: key) + (neighbor energy).\r\t\t\t\t\tnewPath := path copy.\r\t\t\t\t\tnewPath addLast: neighborPoint.\r\t\t\t\t\tnewPaths at: pathID put: newPath.\r\t\t\t\t\tpathEnergies at: pathID put: newVal.\r\t\t\t\t\tpathID := (pathID + 1) \r\t\t\t\t\t\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifTrue:[\r\t\t\t\t\t"Transcript crShow: path.\r\t\t\t\t\tTranscript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).\r\t\t\t\t\tTranscript crShow: \'DOES  INCLUDE\'."\r\t\t\t\t\t].\r\t\t\t\t ]. \r\t\t\t ].\r\t\tpaths := newPaths copy.\r\t\tcurrentItterations := currentItterations + 1.\r\t\t ].\r\tbestPathID  := 0.\r\t1 to: ((pathEnergies values) size) do: [ \r\t\t\t:key|\r\t\t\t((pathEnergies values max) = (pathEnergies at: key))ifTrue:[\r\t\t\t\tbestPathID := key\r\t\t\t\t].\r\t\t\t].\r\tbestPath := paths at: bestPathID.\r\tbestPath removeAt: 1.\r\tdirectionList := bestPath. "stores best path as a instance variable"\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/1/2020 00:05',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-01T00:07:15.08619-05:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList size = 0)ifTrue: [ \r\t\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\t\r\tpoint := directionList first.\r\tdirection := self DetermineRobotMovementFromPoint: point Robot: sketchRobot. \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/1/2020 00:05',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tTranscript crShow: directionList.\r\tpoint := directionList first.\r\tdirection := self DetermineRobotMovementFromPoint: point Robot: sketchRobot. \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/1/2020 00:07',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-01T00:08:47.56219-05:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tTranscript crShow: directionList.\r\tpoint := directionList first.\r\tdirection := self DetermineRobotMovementFromPoint: point Robot: sketchRobot. \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/1/2020 00:07',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tpoint := directionList first.\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/1/2020 00:08',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-01T00:09:59.01619-05:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tpoint := directionList first.\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/1/2020 00:08',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\t\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/1/2020 00:09',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-01T00:14:14.77719-05:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'DetermineRobotMovementFromPoint:Robot:',			#protocol : #'as yet unclassified',			#sourceCode : 'DetermineRobotMovementFromPoint: point Robot: sketchRobot\r\t| fourNeighbors directionDict|\r\tfourNeighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\tdirectionDict := Dictionary newFrom: {1 -> RobotWest soleInstance . 2 -> RobotSouth soleInstance . 3 -> RobotEast soleInstance . 4 -> RobotNorth soleInstance .}.\r\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (fourNeighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(neighborPoint = point)ifTrue: [ \r\t\t\t\t\t^(directionDict at: neighborIndex)\r\t\t\t\t].\r\t].\r\t',			#stamp : 'BenTran 2/1/2020 00:03',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'DetermineRobotMovementFromPoint:Robot:',			#protocol : #'as yet unclassified',			#sourceCode : 'DetermineRobotMovementFromPoint: point Robot: sketchRobot\r\t| fourNeighbors directionDict|\r\tfourNeighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"\r\tdirectionDict := Dictionary newFrom: {1 -> RobotEast soleInstance . 2 -> RobotSouth soleInstance . 3 -> RobotWest soleInstance . 4 -> RobotNorth soleInstance .}.\r\t1 to: 4 do: [ \r\t\t\t\t: neighborIndex|\r\t\t\t\t|neighbor neighborPoint|.\r\t\t\t\tneighbor := (fourNeighbors at: neighborIndex). \r\t\t\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t\t\t(neighborPoint = point)ifTrue: [ \r\t\t\t\t\t^(directionDict at: neighborIndex)\r\t\t\t\t].\r\t].\r\t',			#stamp : 'BenTran 2/1/2020 00:14',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-01T00:19:19.63619-05:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 4. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 1/31/2020 23:52',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 6. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/1/2020 00:19',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-01T00:20:38.15719-05:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 6. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/1/2020 00:19',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/1/2020 00:20',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-01T00:22:18.35119-05:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/1/2020 00:20',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 1. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/1/2020 00:22',			#package : #JRMPC-Phase1-Minds		}	}}