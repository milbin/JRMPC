OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T14:46:38.893348-05:00' ],		#prior : OmReference [ 'Pharo7.0.4-0-32bit-ccd1f64.4ylepghtqxadglbdoaytnst3e', '1' ],		#self : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T14:46:38.922348-05:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T14:46:38.947348-05:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T14:46:38.972348-05:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T14:46:38.993348-05:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T14:46:39.036348-05:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY directionList\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #directionList,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY directionList scanningRadius\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #directionList,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #scanningRadius,					#parent : @35				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @35			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @35,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T14:46:39.146348-05:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 4. "number of layers deep that the NN should look at"\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 10:00',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 4. "number of layers deep that the NN should look at"\r\tscanningRadius := 5.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 14:46',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T14:47:16.865348-05:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t\r\t\t\r\t\t\r\t\t ]\r\t\r\t\r\t\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 14:47',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T14:47:28.262348-05:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:Robot:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: scanningRadius Robot: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t\r\t\t\r\t\t\r\t\t ]\r\t\r\t\r\t\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 11:35',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:08:15.110348-05:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\t\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/1/2020 00:09',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tself Dijkstra: sketchRobot. \r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 15:08',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:33:42.773348-05:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t\r\t\t\r\t\t\r\t\t ]\r\t\r\t\r\t\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 14:47',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t(unVisited size > 0)whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t(value < minValue )ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t(bestPath size = 0)whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:33',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:34:32.865348-05:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself plotPathForNN: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tself Dijkstra: sketchRobot. \r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 15:08',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 15:34',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:34:35.801348-05:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t(unVisited size > 0)whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t(value < minValue )ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t(bestPath size = 0)whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:33',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t(unVisited size > 0)whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t(value < minValue )ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t(bestPath isEmpty )whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:34',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:37:02.286348-05:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'standardizePoint:Integer:Integer:Integer:',			#protocol : #'as yet unclassified',			#sourceCode : 'standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows\r\t"this will take a given coordinate and it wrap around the board"\r\t| newXPoint newYPoint |.\r\tnewXPoint := (xPoint \\\\ columns) abs. "\\\\ is the same as % in python"\r\tnewYPoint := (yPoint \\\\ rows) abs.\r\t^ Array newFrom: {newXPoint . newYPoint}.\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:37',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:37:11.176348-05:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'standardizePoint:Integer:',			#protocol : #'as yet unclassified',			#sourceCode : 'standardizePoint: xPoint Integer: yPoint\r\t"this will take a given coordinate and it wrap around the board"\r\t| newXPoint newYPoint |.\r\tnewXPoint := (xPoint rem) abs.\r\tnewYPoint := (yPoint rem) abs.\r\t^ Array newFrom: {newXPoint . newYPoint}.\r\t\r\t',			#stamp : 'BenTran 2/6/2020 10:08',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:38:12.848348-05:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t(unVisited size > 0)whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t(value < minValue )ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t(bestPath isEmpty )whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:34',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t(unVisited size > 0)whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t(value < minValue )ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t(bestPath isEmpty )whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:38',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:42:16.008348-05:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t(unVisited size > 0)whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t(value < minValue )ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t(bestPath isEmpty )whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:38',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t(value < minValue )ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:42',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:45:36.296348-05:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t(value < minValue )ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:42',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t(value < minValue )ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tTranscript crShow: unVisited.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:45',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:53:26.151348-05:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t(value < minValue )ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tTranscript crShow: unVisited.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:45',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tTranscript crShow: true not.\r\tTranscript crShow: unVisited.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:53',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:54:07.479348-05:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tTranscript crShow: true not.\r\tTranscript crShow: unVisited.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:53',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tTranscript crShow: true not.\r\t"Transcript crShow: unVisited."\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:54',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:56:37.215348-05:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 4. "number of layers deep that the NN should look at"\r\tscanningRadius := 5.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 14:46',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 4. "number of layers deep that the NN should look at"\r\tscanningRadius := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 15:56',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:56:38.400348-05:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tTranscript crShow: true not.\r\t"Transcript crShow: unVisited."\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:54',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:56',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T15:57:41.943348-05:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:56',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\tTranscript crShow: pointsList.\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:57',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:05:02.951348-05:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'setupOn:',			#protocol : #running,			#sourceCode : 'setupOn: sketchRobot\r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method facilitates initial setup of the mind related to the map parameters.\r\n\t It is called once by the competition framework when the mind is instantiated.\r\n \t \'sketchRobot\' is a copy of the world as seen by the robot\'s scanners \r\n\t"\r\t"chekc for yellow square"\r\t|width height itterator|. "initilize the variable"\r   width := sketchRobot map width.\r   height := sketchRobot map height.\r\titterator := 1.\r   1 to: height do:[ "for loop"\r   \t\t:y | "assigns itterator number to i" \r       1 to: width do:[\r       \t:x |\r\t\t\t|energyValue|.\r\t\t\tenergyValue := ((sketchRobot map cellAt: x@y) energy).\r         (energyValue> 90) "the x@y signifies a point object ex: (1,1) or (5,99)"\r         ifTrue: [ \r         \thighestPointSquares add: energyValue.\r\t\t\titterator := itterator + 1.\r         \tdoesYellowSquareExist := true.\r         ].\r\t\t].\r\t].\r\tTranscript show: (highestPointSquares sorted).\r\t\r\t\r\t\r\n',			#stamp : 'BenTran 1/31/2020 11:31',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'setupOn:',			#protocol : #running,			#sourceCode : 'setupOn: sketchRobot\r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method facilitates initial setup of the mind related to the map parameters.\r\n\t It is called once by the competition framework when the mind is instantiated.\r\n \t \'sketchRobot\' is a copy of the world as seen by the robot\'s scanners \r\n\t"\r\t"chekc for yellow square"\r\t|width height itterator|. "initilize the variable"\r   width := sketchRobot map width.\r   height := sketchRobot map height.\r\titterator := 1.\r   1 to: height do:[ "for loop"\r   \t\t:y | "assigns itterator number to i" \r       1 to: width do:[\r       \t:x |\r\t\t\t|energyValue|.\r\t\t\tenergyValue := ((sketchRobot map cellAt: x@y) energy).\r         (energyValue> 90) "the x@y signifies a point object ex: (1,1) or (5,99)"\r         ifTrue: [ \r         \thighestPointSquares add: energyValue.\r\t\t\titterator := itterator + 1.\r         \tdoesYellowSquareExist := true.\r         ].\r\t\t].\r\t].\r\t\r\t\r\t\r\n',			#stamp : 'BenTran 2/6/2020 16:05',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:05:05.106348-05:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\tTranscript crShow: pointsList.\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:57',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\tTranscript crShow: pointsList.\r\tTranscript crShow: grid.\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:05',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:06:43.438348-05:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\tTranscript crShow: pointsList.\r\tTranscript crShow: grid.\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:05',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\tTranscript crShow: pointsList.\r\tTranscript crShow: grid.\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:06',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:07:23.457348-05:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 15:34',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tTranscript crShow: \'HERE\'.\r\t\tself Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 16:07',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:08:14.647348-05:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\tTranscript crShow: pointsList.\r\tTranscript crShow: grid.\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\t^bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:06',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\tTranscript crShow: pointsList.\r\tTranscript crShow: grid.\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:08',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:10:10.856348-05:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\tTranscript crShow: pointsList.\r\tTranscript crShow: grid.\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:08',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\tTranscript crShow: pointsList.\r\tTranscript crShow: grid.\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:10',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:11:31.993348-05:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\tTranscript crShow: pointsList.\r\tTranscript crShow: grid.\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:10',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\tTranscript crShow: \'HERE123\'.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:11',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:15:20.084348-05:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\tTranscript crShow: \'HERE123\'.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:11',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\tTranscript crShow: \'HERE123\'.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:15',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:15:36.601348-05:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tTranscript crShow: \'HERE\'.\r\t\tself Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 16:07',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 16:15',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:16:17.999348-05:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'recoverOn:',			#protocol : #running,			#sourceCode : 'recoverOn: sketchRobot\r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t If the mind doesn\'t complete its step within the designated time, its process is terminated.\r\n\t Depending on how you manage your data objects, they may end up corrupted.\r\n\t This method allows the mind to reset and continue playing.\r\n \t \'sketchRobot\' is a copy of the world as seen by the robot\'s scanners \r\n\t"\r\n\r\n\tself setupOn: sketchRobot',			#stamp : '',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'recoverOn:',			#protocol : #running,			#sourceCode : 'recoverOn: sketchRobot\r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t If the mind doesn\'t complete its step within the designated time, its process is terminated.\r\n\t Depending on how you manage your data objects, they may end up corrupted.\r\n\t This method allows the mind to reset and continue playing.\r\n \t \'sketchRobot\' is a copy of the world as seen by the robot\'s scanners \r\n\t"\r\tTranscript crShow: \'PROGRAM TOOK TOO LONG, EXITING\'.\r\n\r\n\tself setupOn: sketchRobot',			#stamp : 'BenTran 2/6/2020 16:16',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:18:40.048348-05:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\tTranscript crShow: \'HERE123\'.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:15',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\tTranscript crShow: \'HERE123\'.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:18',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:19:13.269348-05:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\tTranscript crShow: \'HERE123\'.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:18',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\tTranscript crShow: \'HERE123\'.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:19',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:20:40.569348-05:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\tTranscript crShow: \'HERE123\'.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:19',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\tTranscript crShow: ((distanceFromStart at: point) < shortestPathLength).\r\t\t\tTranscript crShow: (point ~= startingPoint).\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:20',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:22:45.264348-05:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\tTranscript crShow: ((distanceFromStart at: point) < shortestPathLength).\r\t\t\tTranscript crShow: (point ~= startingPoint).\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:20',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\tTranscript crShow: point.\r\t\t\tTranscript crShow: startingPoint.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:22',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:24:32.228348-05:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\tTranscript crShow: point.\r\t\t\tTranscript crShow: startingPoint.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~= startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:22',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\tTranscript crShow: point.\r\t\t\tTranscript crShow: startingPoint.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:24',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:26:40.956348-05:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\tTranscript crShow: point.\r\t\t\tTranscript crShow: startingPoint.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ \r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t(shouldBreak)whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:24',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\tTranscript crShow: (point ~~ startingPoint).\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:26',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:28:13.894348-05:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\tTranscript crShow: (point ~~ startingPoint).\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\t ] ifFalse:[\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:26',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:28',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:29:07.429348-05:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:28',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: \'HERE1\'.\r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:29',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:29:35.497348-05:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: \'HERE1\'.\r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:29',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:29',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:30:58.446348-05:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:29',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:30',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:34:05.978348-05:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighbor )ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:30',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:34',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:35:46.319348-05:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:34',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tTranscript crShow: \'im here\'.\r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:35',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:36:37.730348-05:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tTranscript crShow: \'im here\'.\r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:35',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:36',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:38:57.718348-05:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE2\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: \'FOUND PATH\'.\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:36',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:38',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:39:32.782348-05:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:38',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:39',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:41:07.758348-05:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 16:15',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tTranscript crShow: \'HERE\'.\r\t\tself Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 16:41',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:43:53.584348-05:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\tTranscript crShow: bestPath.\r\t\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:39',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:43',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:45:07.950348-05:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tTranscript crShow: \'HERE\'.\r\t\tself Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 16:41',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tTranscript crShow: directionList.\r\t\tself Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 16:45',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:46:07.205348-05:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:43',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:46',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:50:48.398348-05:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:46',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:50',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:52:57.879348-05:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:50',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: \'HERE++++++++++++++++++++++++++++++++++++++++++-----------------------\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:52',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:54:28.041348-05:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: \'HERE++++++++++++++++++++++++++++++++++++++++++-----------------------\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:52',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: \'HERE++++++++++++++++++++++++++++++++++++++++++-----------------------\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tTranscript crShow: (newPoint = startingPoint).\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:54',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:55:37.392348-05:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: \'HERE++++++++++++++++++++++++++++++++++++++++++-----------------------\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tTranscript crShow: (newPoint = startingPoint).\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:54',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: \'HERE++++++++++++++++++++++++++++++++++++++++++-----------------------\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tTranscript crShow: (newPoint = startingPoint).\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:55',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:56:57.251348-05:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: \'HERE++++++++++++++++++++++++++++++++++++++++++-----------------------\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tTranscript crShow: (newPoint = startingPoint).\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:55',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:56',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T16:58:56.290348-05:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:56',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:58',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:03:20.922348-05:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 16:58',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\tTranscript crShow: distance.\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:03',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:04:31.614348-05:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\tTranscript crShow: distance.\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:03',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\tTranscript crShow: distance.\r\t\t\tTranscript crShow: currentPoint.\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:04',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:21:01.918348-05:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\tTranscript crShow: distance.\r\t\t\tTranscript crShow: currentPoint.\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:04',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\tTranscript crShow: distance.\r\t\t\tTranscript crShow: currentPoint.\r\t\t\tTranscript crShow: distanceFromStart.\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:21',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:22:42.560348-05:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\tTranscript crShow: distance.\r\t\t\tTranscript crShow: currentPoint.\r\t\t\tTranscript crShow: distanceFromStart.\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:21',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance > 1000000000000)ifTrue: [ \r\t\t\tTranscript crShow: distance.\r\t\t\tTranscript crShow: currentPoint.\r\t\t\tTranscript crShow: distanceFromStart.\r\t\t\t].\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:22',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:24:54.693348-05:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 0 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t0 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance > 1000000000000)ifTrue: [ \r\t\t\tTranscript crShow: distance.\r\t\t\tTranscript crShow: currentPoint.\r\t\t\tTranscript crShow: distanceFromStart.\r\t\t\t].\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:22',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance > 1000000000000)ifTrue: [ \r\t\t\tTranscript crShow: distance.\r\t\t\tTranscript crShow: currentPoint.\r\t\t\tTranscript crShow: distanceFromStart.\r\t\t\t].\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:24',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:27:36.622348-05:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'standardizePoint:Integer:Integer:Integer:',			#protocol : #'as yet unclassified',			#sourceCode : 'standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows\r\t"this will take a given coordinate and it wrap around the board"\r\t| newXPoint newYPoint |.\r\tnewXPoint := (xPoint \\\\ columns) abs. "\\\\ is the same as % in python"\r\tnewYPoint := (yPoint \\\\ rows) abs.\r\t^ Array newFrom: {newXPoint . newYPoint}.\r\t\r\t',			#stamp : 'BenTran 2/6/2020 15:37',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'standardizePoint:Integer:Integer:Integer:',			#protocol : #'as yet unclassified',			#sourceCode : 'standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows\r\t"this will take a given coordinate and it wrap around the board"\r\t| newXPoint newYPoint |.\r\tnewXPoint := ((xPoint \\\\ columns) abs) + 1. "\\\\ is the same as % in python, coordinate system starts at 1,1 so we need to shift everything by 1"\r\tnewYPoint := ((yPoint \\\\ rows) abs) + 1.\r\t^ Array newFrom: {newXPoint . newYPoint}.\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:27',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:29:36.812348-05:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance > 1000000000000)ifTrue: [ \r\t\t\tTranscript crShow: distance.\r\t\t\tTranscript crShow: currentPoint.\r\t\t\tTranscript crShow: distanceFromStart.\r\t\t\t].\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:24',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:29',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:29:50.308348-05:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:29',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:29',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:30:26.952348-05:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:29',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: previousVertex.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:30',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:31:29.470348-05:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: previousVertex.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:30',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: previousVertex.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:31',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:32:56.321348-05:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: previousVertex.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:31',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:32',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:39:24.125348-05:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:32',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tTranscript crShow: (Array newFrom: {xPoint . yPoint }).\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\tTranscript crShow: point.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:39',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:40:48.907348-05:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tTranscript crShow: (Array newFrom: {xPoint . yPoint }).\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\tTranscript crShow: point.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:39',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tTranscript crShow: (10\\\\3).\r\t\t\tTranscript crShow: (Array newFrom: {xPoint . yPoint }).\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\tTranscript crShow: point.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:40',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:41:09.301348-05:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tTranscript crShow: (10\\\\3).\r\t\t\tTranscript crShow: (Array newFrom: {xPoint . yPoint }).\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\tTranscript crShow: point.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:40',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tTranscript crShow: (0\\\\3).\r\t\t\tTranscript crShow: (Array newFrom: {xPoint . yPoint }).\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\tTranscript crShow: point.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:41',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:42:34.878348-05:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 4. "number of layers deep that the NN should look at"\r\tscanningRadius := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 15:56',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 6. "number of layers deep that the NN should look at"\r\tscanningRadius := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 17:42',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:44:29.997348-05:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 6. "number of layers deep that the NN should look at"\r\tscanningRadius := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 17:42',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 10. "number of layers deep that the NN should look at"\r\tscanningRadius := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 17:44',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:47:12.944348-05:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tTranscript crShow: (0\\\\3).\r\t\t\tTranscript crShow: (Array newFrom: {xPoint . yPoint }).\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\tTranscript crShow: point.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:41',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tTranscript crShow: (Array newFrom: {xPoint . yPoint }).\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\tTranscript crShow: point.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:47',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:48:00.981348-05:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tTranscript crShow: (Array newFrom: {xPoint . yPoint }).\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\tTranscript crShow: point.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:47',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tTranscript crShow: x.\r\t\t\tTranscript crShow: scanningRadius.\r\t\t\tTranscript crShow: xPoint.\r\t\t\tTranscript crShow: (Array newFrom: {xPoint . yPoint }).\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\tTranscript crShow: point.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:48',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:48:28.610348-05:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 10. "number of layers deep that the NN should look at"\r\tscanningRadius := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 17:44',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tscanningRadius := 10.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 17:48',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:49:00.844348-05:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tscanningRadius := 10.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 17:48',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tscanningRadius := 4.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 17:49',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:54:29.550348-05:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'standardizePoint:Integer:Integer:Integer:',			#protocol : #'as yet unclassified',			#sourceCode : 'standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows\r\t"this will take a given coordinate and it wrap around the board"\r\t| newXPoint newYPoint |.\r\tnewXPoint := ((xPoint \\\\ columns) abs) + 1. "\\\\ is the same as % in python, coordinate system starts at 1,1 so we need to shift everything by 1"\r\tnewYPoint := ((yPoint \\\\ rows) abs) + 1.\r\t^ Array newFrom: {newXPoint . newYPoint}.\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:27',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'standardizePoint:Integer:Integer:Integer:',			#protocol : #'as yet unclassified',			#sourceCode : 'standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows\r\t"this will take a given coordinate and it wrap around the board"\r\t| newXPoint newYPoint |.\r\t\r\tnewXPoint := ((xPoint \\\\ columns) abs). "\\\\ is the same as % in python, coordinate system starts at 1,1 so we need to shift everything by 1"\r\tnewYPoint := ((yPoint \\\\ rows) abs).\r\t\r\t(xPoint = 0)ifTrue: [ \r\t\tnewXPoint := columns \r\t\t ].\r\t(yPoint = 0)ifTrue: [ \r\t\tnewXPoint := rows \r\t\t ].\r\t\r\t^ Array newFrom: {newXPoint . newYPoint}.\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:54',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T17:54:58.231348-05:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tTranscript crShow: x.\r\t\t\tTranscript crShow: scanningRadius.\r\t\t\tTranscript crShow: xPoint.\r\t\t\tTranscript crShow: (Array newFrom: {xPoint . yPoint }).\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\tTranscript crShow: point.\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:48',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:54',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:28:36.241348-05:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:54',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\tTranscript crShow: grid size.\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:28',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:29:54.327348-05:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\tTranscript crShow: grid size.\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:28',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\tTranscript crShow: grid size.\r\tTranscript crShow: grid.\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:29',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:30:33.146348-05:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'standardizePoint:Integer:Integer:Integer:',			#protocol : #'as yet unclassified',			#sourceCode : 'standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows\r\t"this will take a given coordinate and it wrap around the board"\r\t| newXPoint newYPoint |.\r\t\r\tnewXPoint := ((xPoint \\\\ columns) abs). "\\\\ is the same as % in python, coordinate system starts at 1,1 so we need to shift everything by 1"\r\tnewYPoint := ((yPoint \\\\ rows) abs).\r\t\r\t(xPoint = 0)ifTrue: [ \r\t\tnewXPoint := columns \r\t\t ].\r\t(yPoint = 0)ifTrue: [ \r\t\tnewXPoint := rows \r\t\t ].\r\t\r\t^ Array newFrom: {newXPoint . newYPoint}.\r\t\r\t',			#stamp : 'BenTran 2/6/2020 17:54',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'standardizePoint:Integer:Integer:Integer:',			#protocol : #'as yet unclassified',			#sourceCode : 'standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows\r\t"this will take a given coordinate and it wrap around the board"\r\t| newXPoint newYPoint |.\r\t\r\tnewXPoint := ((xPoint \\\\ columns) abs). "\\\\ is the same as % in python, coordinate system starts at 1,1 so we need to shift everything by 1"\r\tnewYPoint := ((yPoint \\\\ rows) abs).\r\t\r\t(xPoint = 0)ifTrue: [ \r\t\tnewXPoint := columns \r\t\t ].\r\t(yPoint = 0)ifTrue: [ \r\t\tnewYPoint := rows \r\t\t ].\r\t\r\t^ Array newFrom: {newXPoint . newYPoint}.\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:30',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:31:50.504348-05:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBToDoRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBToDoRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#RobotMind #plotPathForNN: #false)) #\'2020-01-31T22:51:44.02919-05:00\') )',			#stamp : 'BenTran 1/31/2020 22:51',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBToDoRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBToDoRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#RobotMind #plotPathForNN: #false)) #\'2020-01-31T22:51:44.02919-05:00\') #(#(#RGMethodDefinition #(#RobotMind #Dijkstra: #false)) #\'2020-02-06T22:31:50.488348-05:00\') )',			#stamp : 'BenTran 2/6/2020 22:31',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:32:01.346348-05:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBToDoRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBToDoRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#RobotMind #plotPathForNN: #false)) #\'2020-01-31T22:51:44.02919-05:00\') #(#(#RGMethodDefinition #(#RobotMind #Dijkstra: #false)) #\'2020-02-06T22:31:50.488348-05:00\') )',			#stamp : 'BenTran 2/6/2020 22:31',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestJRMPCPhaseMinds class',				#isMetaSide : true			},			#name : #ruleRBToDoRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBToDoRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#RobotMind #plotPathForNN: #false)) #\'2020-01-31T22:51:44.02919-05:00\') #(#(#RGMethodDefinition #(#RobotMind #Dijkstra: #false)) #\'2020-02-06T22:31:50.488348-05:00\') #(#(#RGClassDefinition #(#RobotMind)) #\'2020-02-06T22:32:01.332348-05:00\') )',			#stamp : 'BenTran 2/6/2020 22:32',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:33:36.306348-05:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\tTranscript crShow: grid size.\r\tTranscript crShow: grid.\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:29',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:33',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:34:22.206348-05:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:33',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:34',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:36:28.786348-05:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:34',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: grid.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:36',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:39:13.537348-05:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: grid.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:36',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: grid.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:39',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:39:23.901348-05:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: grid.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:39',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: \'HERE^^\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: grid.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:39',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:43:02.595348-05:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: \'HERE^^\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: grid.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:39',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: \'HERE^^\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'Found Starting Point\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: previousVertex.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:43',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:44:07.196348-05:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: \'HERE^^\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: point. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'Found Starting Point\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: previousVertex.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:43',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: \'HERE^^\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'Found Starting Point\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: previousVertex.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:44',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:45:20.035348-05:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: \'HERE^^\'.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'Found Starting Point\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: previousVertex.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:44',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: previousVertex.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:45',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:46:33.025348-05:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: path.\r\t\t\t\t\t\t\tTranscript crShow: scanningRadius.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\tTranscript crShow: previousVertex.\r\tTranscript crShow: distanceFromStart.\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:45',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:46',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:48:31.358348-05:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:46',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:48',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:51:32.137348-05:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tscanningRadius := 4.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 17:49',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tscanningRadius := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 22:51',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:53:17.407348-05:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:48',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\tTranscript crShow: previousVertex.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:53',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:54:58.779348-05:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tscanningRadius := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 22:51',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tscanningRadius := 1.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 22:54',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:57:27.044348-05:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\tTranscript crShow: previousVertex.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:53',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:57',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T22:59:33.391348-05:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:57',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:59',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:00:54.700348-05:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:59',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: (point ~~ startingPoint).\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:00',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:01:35.784348-05:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: (point ~~ startingPoint).\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:00',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: (point = startingPoint).\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:01',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:02:55.137348-05:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & (point ~~ startingPoint))ifTrue: [ "~~ means not equal to"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: (point = startingPoint).\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:01',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point ~~ startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: (point = startingPoint) not.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:02',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:03:58.647348-05:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point ~~ startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tTranscript crShow: point.\r\t\t\t\tTranscript crShow: (point = startingPoint) not.\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\tTranscript crShow: \'HERE\'.\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:02',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\tTranscript crShow: \'HERE\'.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point ~~ startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:03',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:04:50.608348-05:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\tTranscript crShow: \'HERE\'.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point ~~ startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:03',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point ~~ startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:04',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:04:57.932348-05:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point ~~ startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:04',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:04',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:06:20.164348-05:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tscanningRadius := 1.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 22:54',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tscanningRadius := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 23:06',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:07:57.026348-05:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tTranscript crShow: newPoint.\r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\tTranscript crShow: bestPath.\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:04',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:07',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:10:21.779348-05:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tTranscript crShow: directionList.\r\t\tself Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tTranscript crShow: (self DetermineRobotMovementFromPoint: point Robot: sketchRobot).\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 16:45',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'determineDirectionForRobot:',			#protocol : #running,			#sourceCode : 'determineDirectionForRobot: sketchRobot \r    "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.\r     This method is the main entrypoint for competition entries.\r     It is called each time the game world progresses one step in time.\r     \'sketchRobot\' is a copy of the map/robots as seen by a robot\'s scanners (i.e. no internal state). \r     Each time step provides a new independent scan \'sketchRobot\'.\r     The mind instance remains constant across steps (i.e. it has memory across time steps).  \r     The actual map/robots remain inaccessible to prevent accidental corruption of the game.\r    "\r\t| point |\r\t(directionList isEmpty)ifTrue: [ \r\t\tself Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" \r\t\t ].\r\tpoint := directionList first.\r\tTranscript crShow: directionList.\r\tdirection := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). \r\tdirectionList removeAt: 1.\r\t',			#stamp : 'BenTran 2/6/2020 23:10',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:10:57.672348-05:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:07',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: distanceFromStart.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tTranscript crShow: distanceFromStart.\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:10',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:14:53.576348-05:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (unVisited size) do: [:i|\r\t\t| point |.\r\t\tpoint := unVisited at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: distanceFromStart.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tTranscript crShow: distanceFromStart.\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:10',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (grid size) do: [:i|\r\t\t| point |.\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: distanceFromStart.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tTranscript crShow: distanceFromStart.\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:14',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:16:31.708348-05:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (grid size) do: [:i|\r\t\t| point |.\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: distanceFromStart.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tTranscript crShow: distanceFromStart.\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:14',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (grid size) do: [:i|\r\t\t| point |.\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: distanceFromStart.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:16',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:18:14.241348-05:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (grid size) do: [:i|\r\t\t| point |.\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: distanceFromStart.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:16',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (grid size) do: [:i|\r\t\t| point |.\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:18',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:20:16.988348-05:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:20:17.021348-05:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:20:17.056348-05:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:20:17.092348-05:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:20:17.126348-05:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:20:17.181348-05:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY directionList scanningRadius\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #directionList,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #scanningRadius,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY directionList scanningRadius depthDijkstra\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @37				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @37				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @37				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @37				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @37				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @37				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #directionList,					#parent : @37				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #scanningRadius,					#parent : @37				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthDijkstra,					#parent : @37				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @37			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @37,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:20:17.284348-05:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tscanningRadius := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 23:06',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tdepthDijkstra := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 23:20',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:02.412348-05:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:02.447348-05:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:02.482348-05:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:02.515348-05:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:02.548348-05:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:02.601348-05:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY directionList scanningRadius depthDijkstra\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #directionList,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #scanningRadius,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthDijkstra,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY directionList scanningRadius depthDijkstra TEST\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #directionList,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #scanningRadius,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthDijkstra,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #TEST,					#parent : @39				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @39			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @39,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:02.829348-05:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (scanningRadius * 2 + 1) do: [:xCord|\r\t\t1 to: (scanningRadius * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - scanningRadius + xCord).\r\t\t\tyPoint := (y - scanningRadius + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (grid size) do: [:i|\r\t\t| point |.\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > scanningRadius)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (scanningRadius * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tscanningRadius := scanningRadius - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:18',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (TEST * 2 + 1) do: [:xCord|\r\t\t1 to: (TEST * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - TEST + xCord).\r\t\t\tyPoint := (y - TEST + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (grid size) do: [:i|\r\t\t| point |.\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > TEST)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (TEST * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tTEST := TEST - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:24',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:02.987348-05:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:03.020348-05:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:03.055348-05:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:03.088348-05:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:03.122348-05:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:24:03.188348-05:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY directionList scanningRadius depthDijkstra TEST\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #directionList,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #scanningRadius,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthDijkstra,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #TEST,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY directionList depthDijkstra TEST\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #directionList,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthDijkstra,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #TEST,					#parent : @41				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @41			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @41,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:26:23.062348-05:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath|.\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new. \r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t\r\t 1 to: (TEST * 2 + 1) do: [:xCord|\r\t\t1 to: (TEST * 2 + 1) do: [:yCord|\r\t\t\t| xPoint yPoint point|.\r\t\t\txPoint := (x - TEST + xCord).\r\t\t\tyPoint := (y - TEST + yCord).\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self standardizePoint: xPoint Integer: yPoint Integer: (sketchRobot map width) Integer: (sketchRobot map height).\r\t\t\t(grid includes: point)ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\tgrid addLast:  point.\r\t\t\t\tpointsList addLast: ((sketchRobot map cellAt: (point at: 1)@(point at: 2)) energy)\r\t\t\t\t ].\r\t\t ].\r\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom: {x . y}.\r\tdistanceFromStart := Dictionary new. \r\tpreviousVertex := Dictionary new. \r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\t\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: (grid size) do: [:i|\r\t\t| point |.\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.  "1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)).\r\t\t ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\t\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[unVisited size > 0]whileTrue: [ \r\t\t| currentPoint minValue neighbors|.\r\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t"find min value in distanceFromStart dict"\r      minValue := 10000000000000.  "10 billion"\r\t\tdistanceFromStart keysAndValuesDo: [ :key :value |\r\t\t\t((value < minValue) & (visited includes: key) not)ifTrue: [ \r\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\tminValue := value.\t\t\t\t\r\t\t\t\t ].\r\t\t ].\r\t"iterate through neighbors"\r\tneighbors := self getFourNeighbors: (currentPoint at: 1)@(currentPoint at: 2)  Robot: sketchRobot.\r\t1 to: (neighbors size) do:[:i|\r\t\t| neighbor neighborPoint|.\r\t\tneighbor := neighbors at: i.\r\t\tneighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.\r\t\t(grid includes: neighborPoint)ifTrue: [ \r\t\t\t|distance|.\r\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t(distance < distanceFromStart at: neighborPoint)ifTrue: [ \r\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint.\r\t\t\t\t ].\r\t\t\t\r\t\t\t ].\r\t\t].\r\tvisited addLast: currentPoint.\r\tunVisited remove: currentPoint.\r\t].\r\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.  "1 billion"\r\tbestPath := OrderedCollection new.\r\t[bestPath isEmpty]whileTrue: [ \r\t\t1 to: (grid size) do:[:i|\r\t\t\t| point |.\r\t\t\tpoint := grid at: i.\r\t\t\t(((distanceFromStart at: point) < shortestPathLength) & ((point = startingPoint) not))ifTrue: [ "point is not equal to starting point"\r\t\t\t\t| path newPoint shouldBreak|.\r\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\tpath := OrderedCollection new.\r\t\t\t\tpath addLast: point. "the point we are trying to is the first item since the list will be reversed"\r\t\t\t\tnewPoint := point. "initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\tshouldBreak := false.\r\t\t\t\t[shouldBreak]whileFalse: [ \r\t\t\t\t\tnewPoint := previousVertex at: newPoint. "get the previous point and add it to the list"\r\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t(newPoint = startingPoint)ifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t(path size > TEST)ifTrue: [ \r\t\t\t\t\t\t\tshortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\tbestPath := path. "this best path is only truly the best once the while loop has exited"\r\t\t\t\t\t\t\t]. \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t((path size )> (TEST * 4))ifTrue: [ \r\t\t\t\t\t\tshouldBreak := true.\r\t\t\t\t\t\t ].\r\t\t\t\t\t ].\r\t\t\t\t ].\r\t\t\t].\r\t\tTEST := TEST - 1\r\t\t ].\r\t\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath.\r\t\r\t\r\t\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:24',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tscanningRadius := depthDijkstra.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t1 to: scanningRadius * 2 + 1 do: [ :xCord | \r\t\t1 to: scanningRadius * 2 + 1 do: [ :yCord | \r\t\t\t| xPoint yPoint point |\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self\r\t\t\t\tstandardizePoint: xPoint\r\t\t\t\tInteger: yPoint\r\t\t\t\tInteger: sketchRobot map width\r\t\t\t\tInteger: sketchRobot map height.\r\t\t\t(grid includes: point)\r\t\t\t\tifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\t\tgrid addLast: point.\r\t\t\t\t\tpointsList\r\t\t\t\t\t\taddLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy ] ] ].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array\r\t\tnewFrom:\r\t\t\t{x.\r\t\t\ty}.\r\tdistanceFromStart := Dictionary new.\r\tpreviousVertex := Dictionary new.\r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: grid size do: [ :i | \r\t\t| point |\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.\t"1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)) ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[ unVisited size > 0 ]\r\t\twhileTrue: [ | currentPoint minValue neighbors |\r\t\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t\t"find min value in distanceFromStart dict"\r\t\t\tminValue := 10000000000000.\t"10 billion"\r\t\t\tdistanceFromStart\r\t\t\t\tkeysAndValuesDo: [ :key :value | \r\t\t\t\t\tvalue < minValue & (visited includes: key) not\r\t\t\t\t\t\tifTrue: [ currentPoint := key.\r\t\t\t\t\t\t\tminValue := value ] ].\r\t\t\t"iterate through neighbors"\r\t\t\tneighbors := self\r\t\t\t\tgetFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)\r\t\t\t\tRobot: sketchRobot.\r\t\t\t1 to: neighbors size do: [ :i | \r\t\t\t\t| neighbor neighborPoint |\r\t\t\t\tneighbor := neighbors at: i.\r\t\t\t\tneighborPoint := Array\r\t\t\t\t\tnewFrom:\r\t\t\t\t\t\t{neighbor location x.\r\t\t\t\t\t\tneighbor location y}.\r\t\t\t\t(grid includes: neighborPoint)\r\t\t\t\t\tifTrue: [ | distance |\r\t\t\t\t\t\tdistance := (distanceFromStart at: currentPoint)\r\t\t\t\t\t\t\t+ (highestPoint - neighbor energy).\r\t\t\t\t\t\t(distance < distanceFromStart at: neighborPoint)\r\t\t\t\t\t\t\tifTrue: [ distanceFromStart at: neighborPoint put: distance.\r\t\t\t\t\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint ] ] ].\r\t\t\tvisited addLast: currentPoint.\r\t\t\tunVisited remove: currentPoint ].\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.\t"1 billion"\r\tbestPath := OrderedCollection new.\r\t[ bestPath isEmpty ]\r\t\twhileTrue: [ 1 to: grid size do: [ :i | \r\t\t\t\t| point |\r\t\t\t\tpoint := grid at: i.\r\t\t\t\t(distanceFromStart at: point) < shortestPathLength\r\t\t\t\t\t& (point = startingPoint) not\r\t\t\t\t\tifTrue: [ "point is not equal to starting point"\r\t\t\t\t\t\t| path newPoint shouldBreak |\r\t\t\t\t\t\tpath := OrderedCollection new.\r\t\t\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\t\t\tpath addLast: point.\t"the point we are trying to is the first item since the list will be reversed"\r\t\t\t\t\t\tnewPoint := point.\t"initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\t\t\tshouldBreak := false.\r\t\t\t\t\t\t[ shouldBreak ]whileFalse:[\r\t\t\t\t\t\t\t newPoint := previousVertex at: newPoint.\t"get the previous point and add it to the list"\r\t\t\t\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t\t\t\tnewPoint = startingPoint\r\t\t\t\t\t\t\t\t\tifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t\t\t\t\tpath size > scanningRadius\r\t\t\t\t\t\t\t\t\t\t\tifTrue: [ shortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\t\t\t\t\t\tbestPath := path\t"this best path is only truly the best once the while loop has exited" ].\r\t\t\t\t\t\t\t\t\t\tshouldBreak := true ].\r\t\t\t\t\t\t\t\tpath size > (scanningRadius * 4)\r\t\t\t\t\t\t\t\t\tifTrue: [ shouldBreak := true \r\t\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t].\r\t\t\tscanningRadius := scanningRadius - 1 ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath',			#stamp : 'BenTran 2/6/2020 23:26',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:26:52.659348-05:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #BestNeighborMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #BestNeighborMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BestNeighborMind class\r\tinstanceVariableNames: \'\''				},				#name : #'BestNeighborMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BestNeighborMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:26:52.695348-05:00' ],		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #HorizontalScanningMind\r\tinstanceVariableNames: \'stepsToNextRow\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #HorizontalScanningMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #HorizontalScanningMind,						#isMetaSide : false					},					#name : #stepsToNextRow,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'HorizontalScanningMind class\r\tinstanceVariableNames: \'\''				},				#name : #'HorizontalScanningMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #HorizontalScanningMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:26:52.733348-05:00' ],		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #ImprovedRandomWalkMind\r\tinstanceVariableNames: \'random lastDirection\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #ImprovedRandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ImprovedRandomWalkMind,						#isMetaSide : false					},					#name : #lastDirection,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ImprovedRandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'ImprovedRandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ImprovedRandomWalkMind,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:26:52.771348-05:00' ],		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #RandomWalkMind\r\tinstanceVariableNames: \'random\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #RandomWalkMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RandomWalkMind,						#isMetaSide : false					},					#name : #random,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RandomWalkMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RandomWalkMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RandomWalkMind,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:26:52.807348-05:00' ],		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'RobotMind subclass: #MyTeamMind\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'RobotMind'			},			#name : #MyTeamMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyTeamMind class\r\tinstanceVariableNames: \'\''				},				#name : #'MyTeamMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyTeamMind,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:26:52.869348-05:00' ],		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY directionList depthDijkstra TEST\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #directionList,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthDijkstra,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #TEST,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #RobotMind\r\tinstanceVariableNames: \'direction doesYellowSquareExist highestPointSquares depthNN currentX currentY directionList depthDijkstra\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'JRMPC-Phase1-Minds\'',				#superclassName : 'Object'			},			#name : #RobotMind,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #direction,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #doesYellowSquareExist,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #highestPointSquares,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthNN,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentX,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #currentY,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #directionList,					#parent : @39				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RobotMind,						#isMetaSide : false					},					#name : #depthDijkstra,					#parent : @39				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'RobotMind class\r\tinstanceVariableNames: \'\''				},				#name : #'RobotMind class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @39			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RobotMind,					#isMetaSide : false				},				#parent : @39,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #JRMPC-Phase1-Minds,			#package : #JRMPC-Phase1-Minds,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:27:37.423348-05:00' ],		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tscanningRadius := depthDijkstra.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t1 to: scanningRadius * 2 + 1 do: [ :xCord | \r\t\t1 to: scanningRadius * 2 + 1 do: [ :yCord | \r\t\t\t| xPoint yPoint point |\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self\r\t\t\t\tstandardizePoint: xPoint\r\t\t\t\tInteger: yPoint\r\t\t\t\tInteger: sketchRobot map width\r\t\t\t\tInteger: sketchRobot map height.\r\t\t\t(grid includes: point)\r\t\t\t\tifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\t\tgrid addLast: point.\r\t\t\t\t\tpointsList\r\t\t\t\t\t\taddLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy ] ] ].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array\r\t\tnewFrom:\r\t\t\t{x.\r\t\t\ty}.\r\tdistanceFromStart := Dictionary new.\r\tpreviousVertex := Dictionary new.\r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: grid size do: [ :i | \r\t\t| point |\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.\t"1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)) ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[ unVisited size > 0 ]\r\t\twhileTrue: [ | currentPoint minValue neighbors |\r\t\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t\t"find min value in distanceFromStart dict"\r\t\t\tminValue := 10000000000000.\t"10 billion"\r\t\t\tdistanceFromStart\r\t\t\t\tkeysAndValuesDo: [ :key :value | \r\t\t\t\t\tvalue < minValue & (visited includes: key) not\r\t\t\t\t\t\tifTrue: [ currentPoint := key.\r\t\t\t\t\t\t\tminValue := value ] ].\r\t\t\t"iterate through neighbors"\r\t\t\tneighbors := self\r\t\t\t\tgetFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)\r\t\t\t\tRobot: sketchRobot.\r\t\t\t1 to: neighbors size do: [ :i | \r\t\t\t\t| neighbor neighborPoint |\r\t\t\t\tneighbor := neighbors at: i.\r\t\t\t\tneighborPoint := Array\r\t\t\t\t\tnewFrom:\r\t\t\t\t\t\t{neighbor location x.\r\t\t\t\t\t\tneighbor location y}.\r\t\t\t\t(grid includes: neighborPoint)\r\t\t\t\t\tifTrue: [ | distance |\r\t\t\t\t\t\tdistance := (distanceFromStart at: currentPoint)\r\t\t\t\t\t\t\t+ (highestPoint - neighbor energy).\r\t\t\t\t\t\t(distance < distanceFromStart at: neighborPoint)\r\t\t\t\t\t\t\tifTrue: [ distanceFromStart at: neighborPoint put: distance.\r\t\t\t\t\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint ] ] ].\r\t\t\tvisited addLast: currentPoint.\r\t\t\tunVisited remove: currentPoint ].\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.\t"1 billion"\r\tbestPath := OrderedCollection new.\r\t[ bestPath isEmpty ]\r\t\twhileTrue: [ 1 to: grid size do: [ :i | \r\t\t\t\t| point |\r\t\t\t\tpoint := grid at: i.\r\t\t\t\t(distanceFromStart at: point) < shortestPathLength\r\t\t\t\t\t& (point = startingPoint) not\r\t\t\t\t\tifTrue: [ "point is not equal to starting point"\r\t\t\t\t\t\t| path newPoint shouldBreak |\r\t\t\t\t\t\tpath := OrderedCollection new.\r\t\t\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\t\t\tpath addLast: point.\t"the point we are trying to is the first item since the list will be reversed"\r\t\t\t\t\t\tnewPoint := point.\t"initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\t\t\tshouldBreak := false.\r\t\t\t\t\t\t[ shouldBreak ]whileFalse:[\r\t\t\t\t\t\t\t newPoint := previousVertex at: newPoint.\t"get the previous point and add it to the list"\r\t\t\t\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t\t\t\tnewPoint = startingPoint\r\t\t\t\t\t\t\t\t\tifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t\t\t\t\tpath size > scanningRadius\r\t\t\t\t\t\t\t\t\t\t\tifTrue: [ shortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\t\t\t\t\t\tbestPath := path\t"this best path is only truly the best once the while loop has exited" ].\r\t\t\t\t\t\t\t\t\t\tshouldBreak := true ].\r\t\t\t\t\t\t\t\tpath size > (scanningRadius * 4)\r\t\t\t\t\t\t\t\t\tifTrue: [ shouldBreak := true \r\t\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t].\r\t\t\tscanningRadius := scanningRadius - 1 ].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath',			#stamp : 'BenTran 2/6/2020 23:26',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tscanningRadius := depthDijkstra.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t1 to: scanningRadius * 2 + 1 do: [ :xCord | \r\t\t1 to: scanningRadius * 2 + 1 do: [ :yCord | \r\t\t\t| xPoint yPoint point |\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self\r\t\t\t\tstandardizePoint: xPoint\r\t\t\t\tInteger: yPoint\r\t\t\t\tInteger: sketchRobot map width\r\t\t\t\tInteger: sketchRobot map height.\r\t\t\t(grid includes: point)\r\t\t\t\tifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\t\tgrid addLast: point.\r\t\t\t\t\tpointsList\r\t\t\t\t\t\taddLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy ] ] ].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array\r\t\tnewFrom:\r\t\t\t{x.\r\t\t\ty}.\r\tdistanceFromStart := Dictionary new.\r\tpreviousVertex := Dictionary new.\r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: grid size do: [ :i | \r\t\t| point |\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.\t"1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)) ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |\r\t\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t\t"find min value in distanceFromStart dict"\r\t\t\tminValue := 10000000000000.\t"10 billion"\r\t\t\tdistanceFromStart\r\t\t\t\tkeysAndValuesDo: [ :key :value | \r\t\t\t\t\tvalue < minValue & (visited includes: key) not\r\t\t\t\t\t\tifTrue: [ currentPoint := key.\r\t\t\t\t\t\t\tminValue := value ] ].\r\t\t\t"iterate through neighbors"\r\t\t\tneighbors := self\r\t\t\t\tgetFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)\r\t\t\t\tRobot: sketchRobot.\r\t\t\t1 to: neighbors size do: [ :i | \r\t\t\t\t| neighbor neighborPoint |\r\t\t\t\tneighbor := neighbors at: i.\r\t\t\t\tneighborPoint := Array\r\t\t\t\t\tnewFrom:\r\t\t\t\t\t\t{neighbor location x.\r\t\t\t\t\t\tneighbor location y}.\r\t\t\t\t(grid includes: neighborPoint)ifTrue: [ | distance |\r\t\t\t\t\t\tdistance := (distanceFromStart at: currentPoint)\r\t\t\t\t\t\t\t+ (highestPoint - neighbor energy).\r\t\t\t\t\t\t(distance < distanceFromStart at: neighborPoint)\r\t\t\t\t\t\t\tifTrue: [ distanceFromStart at: neighborPoint put: distance.\r\t\t\t\t\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint ] ] ].\r\t\t\tvisited addLast: currentPoint.\r\t\t\tunVisited remove: currentPoint ].\r\t\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.\t"1 billion"\r\tbestPath := OrderedCollection new.\r\t[ bestPath isEmpty ]\r\t\twhileTrue: [ 1 to: grid size do: [ :i | \r\t\t\t\t| point |\r\t\t\t\tpoint := grid at: i.\r\t\t\t\t(distanceFromStart at: point) < shortestPathLength\r\t\t\t\t\t& (point = startingPoint) not\r\t\t\t\t\tifTrue: [ "point is not equal to starting point"\r\t\t\t\t\t\t| path newPoint shouldBreak |\r\t\t\t\t\t\tpath := OrderedCollection new.\r\t\t\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\t\t\tpath addLast: point.\t"the point we are trying to is the first item since the list will be reversed"\r\t\t\t\t\t\tnewPoint := point.\t"initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\t\t\tshouldBreak := false.\r\t\t\t\t\t\t[ shouldBreak ]whileFalse:[\r\t\t\t\t\t\t\t newPoint := previousVertex at: newPoint.\t"get the previous point and add it to the list"\r\t\t\t\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t\t\t\tnewPoint = startingPoint\r\t\t\t\t\t\t\t\t\tifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t\t\t\t\tpath size > scanningRadius\r\t\t\t\t\t\t\t\t\t\t\tifTrue: [ shortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\t\t\t\t\t\tbestPath := path\t"this best path is only truly the best once the while loop has exited" ].\r\t\t\t\t\t\t\t\t\t\tshouldBreak := true ].\r\t\t\t\t\t\t\t\tpath size > (scanningRadius * 4)\r\t\t\t\t\t\t\t\t\tifTrue: [ shouldBreak := true \r\t\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t].\r\t\t\tscanningRadius := scanningRadius - 1 \r\t\t\t].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath',			#stamp : 'BenTran 2/6/2020 23:27',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:34:06.701348-05:00' ],		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tscanningRadius := depthDijkstra.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t1 to: scanningRadius * 2 + 1 do: [ :xCord | \r\t\t1 to: scanningRadius * 2 + 1 do: [ :yCord | \r\t\t\t| xPoint yPoint point |\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self\r\t\t\t\tstandardizePoint: xPoint\r\t\t\t\tInteger: yPoint\r\t\t\t\tInteger: sketchRobot map width\r\t\t\t\tInteger: sketchRobot map height.\r\t\t\t(grid includes: point)\r\t\t\t\tifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\t\tgrid addLast: point.\r\t\t\t\t\tpointsList\r\t\t\t\t\t\taddLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy ] ] ].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array\r\t\tnewFrom:\r\t\t\t{x.\r\t\t\ty}.\r\tdistanceFromStart := Dictionary new.\r\tpreviousVertex := Dictionary new.\r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: grid size do: [ :i | \r\t\t| point |\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.\t"1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)) ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |\r\t\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t\t"find min value in distanceFromStart dict"\r\t\t\tminValue := 10000000000000.\t"10 billion"\r\t\t\tdistanceFromStart\r\t\t\t\tkeysAndValuesDo: [ :key :value | \r\t\t\t\t\tvalue < minValue & (visited includes: key) not\r\t\t\t\t\t\tifTrue: [ currentPoint := key.\r\t\t\t\t\t\t\tminValue := value ] ].\r\t\t\t"iterate through neighbors"\r\t\t\tneighbors := self\r\t\t\t\tgetFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)\r\t\t\t\tRobot: sketchRobot.\r\t\t\t1 to: neighbors size do: [ :i | \r\t\t\t\t| neighbor neighborPoint |\r\t\t\t\tneighbor := neighbors at: i.\r\t\t\t\tneighborPoint := Array\r\t\t\t\t\tnewFrom:\r\t\t\t\t\t\t{neighbor location x.\r\t\t\t\t\t\tneighbor location y}.\r\t\t\t\t(grid includes: neighborPoint)ifTrue: [ | distance |\r\t\t\t\t\t\tdistance := (distanceFromStart at: currentPoint)\r\t\t\t\t\t\t\t+ (highestPoint - neighbor energy).\r\t\t\t\t\t\t(distance < distanceFromStart at: neighborPoint)\r\t\t\t\t\t\t\tifTrue: [ distanceFromStart at: neighborPoint put: distance.\r\t\t\t\t\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint ] ] ].\r\t\t\tvisited addLast: currentPoint.\r\t\t\tunVisited remove: currentPoint ].\r\t\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.\t"1 billion"\r\tbestPath := OrderedCollection new.\r\t[ bestPath isEmpty ]\r\t\twhileTrue: [ 1 to: grid size do: [ :i | \r\t\t\t\t| point |\r\t\t\t\tpoint := grid at: i.\r\t\t\t\t(distanceFromStart at: point) < shortestPathLength\r\t\t\t\t\t& (point = startingPoint) not\r\t\t\t\t\tifTrue: [ "point is not equal to starting point"\r\t\t\t\t\t\t| path newPoint shouldBreak |\r\t\t\t\t\t\tpath := OrderedCollection new.\r\t\t\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\t\t\tpath addLast: point.\t"the point we are trying to is the first item since the list will be reversed"\r\t\t\t\t\t\tnewPoint := point.\t"initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\t\t\tshouldBreak := false.\r\t\t\t\t\t\t[ shouldBreak ]whileFalse:[\r\t\t\t\t\t\t\t newPoint := previousVertex at: newPoint.\t"get the previous point and add it to the list"\r\t\t\t\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t\t\t\tnewPoint = startingPoint\r\t\t\t\t\t\t\t\t\tifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t\t\t\t\tpath size > scanningRadius\r\t\t\t\t\t\t\t\t\t\t\tifTrue: [ shortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\t\t\t\t\t\tbestPath := path\t"this best path is only truly the best once the while loop has exited" ].\r\t\t\t\t\t\t\t\t\t\tshouldBreak := true ].\r\t\t\t\t\t\t\t\tpath size > (scanningRadius * 4)\r\t\t\t\t\t\t\t\t\tifTrue: [ shouldBreak := true \r\t\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t].\r\t\t\tscanningRadius := scanningRadius - 1 \r\t\t\t].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath',			#stamp : 'BenTran 2/6/2020 23:27',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tscanningRadius := depthDijkstra.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t1 to: scanningRadius * 2 + 1 do: [ :xCord | \r\t\t1 to: scanningRadius * 2 + 1 do: [ :yCord | \r\t\t\t| xPoint yPoint point |\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self\r\t\t\t\tstandardizePoint: xPoint\r\t\t\t\tInteger: yPoint\r\t\t\t\tInteger: sketchRobot map width\r\t\t\t\tInteger: sketchRobot map height.\r\t\t\t(grid includes: point) ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\t\tgrid addLast: point.\r\t\t\t\t\tpointsList\r\t\t\t\t\t\taddLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy \r\t\t\t\t\t\t] \r\t\t\t\t\t] \r\t\t\t\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom:{x . y}.\r\tdistanceFromStart := Dictionary new.\r\tpreviousVertex := Dictionary new.\r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: grid size do: [ :i | \r\t\t| point |\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.\t"1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)) ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |\r\t\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t\t"find min value in distanceFromStart dict"\r\t\t\tminValue := 10000000000000.\t"10 billion"\r\t\t\tdistanceFromStart\r\t\t\t\tkeysAndValuesDo: [ :key :value | \r\t\t\t\t\t(value < minValue & (visited includes: key) not)\tifTrue: [ \r\t\t\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\t\t\tminValue := value \r\t\t\t\t\t\t\t]\r\t\t\t\t\t\t ].\r\t\t\t"iterate through neighbors"\r\t\t\tneighbors := self\tgetFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)\tRobot: sketchRobot.\r\t\t\t1 to: neighbors size do: [ :i | \r\t\t\t\t| neighbor neighborPoint |\r\t\t\t\tneighbor := neighbors at: i.\r\t\t\t\tneighborPoint := Array newFrom: {neighbor location x. neighbor location y}.\r\t\t\t\t(grid includes: neighborPoint)ifTrue: [ | distance |\r\t\t\t\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t\t\t\t(distance < distanceFromStart at: neighborPoint) ifTrue: [ \r\t\t\t\t\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\t\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t] \r\t\t\t\t\t\t].\r\t\t\tvisited addLast: currentPoint.\r\t\t\tunVisited remove: currentPoint \r\t\t\t].\r\t\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.\t"1 billion"\r\tbestPath := OrderedCollection new.\r\t[ bestPath isEmpty ]\r\t\twhileTrue: [ 1 to: grid size do: [ :i | \r\t\t\t\t| point |\r\t\t\t\tpoint := grid at: i.\r\t\t\t\t(distanceFromStart at: point) < shortestPathLength\r\t\t\t\t\t& (point = startingPoint) not\r\t\t\t\t\tifTrue: [ "point is not equal to starting point"\r\t\t\t\t\t\t| path newPoint shouldBreak |\r\t\t\t\t\t\tpath := OrderedCollection new.\r\t\t\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\t\t\tpath addLast: point.\t"the point we are trying to is the first item since the list will be reversed"\r\t\t\t\t\t\tnewPoint := point.\t"initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\t\t\tshouldBreak := false.\r\t\t\t\t\t\t[ shouldBreak ]whileFalse:[\r\t\t\t\t\t\t\t newPoint := previousVertex at: newPoint.\t"get the previous point and add it to the list"\r\t\t\t\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t\t\t\tnewPoint = startingPoint\r\t\t\t\t\t\t\t\t\tifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t\t\t\t\tpath size > scanningRadius\r\t\t\t\t\t\t\t\t\t\t\tifTrue: [ shortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\t\t\t\t\t\tbestPath := path\t"this best path is only truly the best once the while loop has exited" ].\r\t\t\t\t\t\t\t\t\t\tshouldBreak := true ].\r\t\t\t\t\t\t\t\tpath size > (scanningRadius * 4)\r\t\t\t\t\t\t\t\t\tifTrue: [ shouldBreak := true \r\t\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t].\r\t\t\tscanningRadius := scanningRadius - 1 \r\t\t\t].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath',			#stamp : 'BenTran 2/6/2020 23:34',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:35:48.552348-05:00' ],		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tscanningRadius := depthDijkstra.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t1 to: scanningRadius * 2 + 1 do: [ :xCord | \r\t\t1 to: scanningRadius * 2 + 1 do: [ :yCord | \r\t\t\t| xPoint yPoint point |\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self\r\t\t\t\tstandardizePoint: xPoint\r\t\t\t\tInteger: yPoint\r\t\t\t\tInteger: sketchRobot map width\r\t\t\t\tInteger: sketchRobot map height.\r\t\t\t(grid includes: point) ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\t\tgrid addLast: point.\r\t\t\t\t\tpointsList\r\t\t\t\t\t\taddLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy \r\t\t\t\t\t\t] \r\t\t\t\t\t] \r\t\t\t\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom:{x . y}.\r\tdistanceFromStart := Dictionary new.\r\tpreviousVertex := Dictionary new.\r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: grid size do: [ :i | \r\t\t| point |\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.\t"1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)) ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |\r\t\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t\t"find min value in distanceFromStart dict"\r\t\t\tminValue := 10000000000000.\t"10 billion"\r\t\t\tdistanceFromStart\r\t\t\t\tkeysAndValuesDo: [ :key :value | \r\t\t\t\t\t(value < minValue & (visited includes: key) not)\tifTrue: [ \r\t\t\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\t\t\tminValue := value \r\t\t\t\t\t\t\t]\r\t\t\t\t\t\t ].\r\t\t\t"iterate through neighbors"\r\t\t\tneighbors := self\tgetFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)\tRobot: sketchRobot.\r\t\t\t1 to: neighbors size do: [ :i | \r\t\t\t\t| neighbor neighborPoint |\r\t\t\t\tneighbor := neighbors at: i.\r\t\t\t\tneighborPoint := Array newFrom: {neighbor location x. neighbor location y}.\r\t\t\t\t(grid includes: neighborPoint)ifTrue: [ | distance |\r\t\t\t\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t\t\t\t(distance < distanceFromStart at: neighborPoint) ifTrue: [ \r\t\t\t\t\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\t\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t] \r\t\t\t\t\t\t].\r\t\t\tvisited addLast: currentPoint.\r\t\t\tunVisited remove: currentPoint \r\t\t\t].\r\t\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.\t"1 billion"\r\tbestPath := OrderedCollection new.\r\t[ bestPath isEmpty ]\r\t\twhileTrue: [ 1 to: grid size do: [ :i | \r\t\t\t\t| point |\r\t\t\t\tpoint := grid at: i.\r\t\t\t\t(distanceFromStart at: point) < shortestPathLength\r\t\t\t\t\t& (point = startingPoint) not\r\t\t\t\t\tifTrue: [ "point is not equal to starting point"\r\t\t\t\t\t\t| path newPoint shouldBreak |\r\t\t\t\t\t\tpath := OrderedCollection new.\r\t\t\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\t\t\tpath addLast: point.\t"the point we are trying to is the first item since the list will be reversed"\r\t\t\t\t\t\tnewPoint := point.\t"initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\t\t\tshouldBreak := false.\r\t\t\t\t\t\t[ shouldBreak ]whileFalse:[\r\t\t\t\t\t\t\t newPoint := previousVertex at: newPoint.\t"get the previous point and add it to the list"\r\t\t\t\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t\t\t\tnewPoint = startingPoint\r\t\t\t\t\t\t\t\t\tifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t\t\t\t\tpath size > scanningRadius\r\t\t\t\t\t\t\t\t\t\t\tifTrue: [ shortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\t\t\t\t\t\tbestPath := path\t"this best path is only truly the best once the while loop has exited" ].\r\t\t\t\t\t\t\t\t\t\tshouldBreak := true ].\r\t\t\t\t\t\t\t\tpath size > (scanningRadius * 4)\r\t\t\t\t\t\t\t\t\tifTrue: [ shouldBreak := true \r\t\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t].\r\t\t\tscanningRadius := scanningRadius - 1 \r\t\t\t].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath',			#stamp : 'BenTran 2/6/2020 23:34',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tscanningRadius := depthDijkstra.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t1 to: scanningRadius * 2 + 1 do: [ :xCord | \r\t\t1 to: scanningRadius * 2 + 1 do: [ :yCord | \r\t\t\t| xPoint yPoint point |\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self\r\t\t\t\tstandardizePoint: xPoint\r\t\t\t\tInteger: yPoint\r\t\t\t\tInteger: sketchRobot map width\r\t\t\t\tInteger: sketchRobot map height.\r\t\t\t(grid includes: point) ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\t\tgrid addLast: point.\r\t\t\t\t\tpointsList\r\t\t\t\t\t\taddLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy \r\t\t\t\t\t\t] \r\t\t\t\t\t] \r\t\t\t\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom:{x . y}.\r\tdistanceFromStart := Dictionary new.\r\tpreviousVertex := Dictionary new.\r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: grid size do: [ :i | \r\t\t| point |\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.\t"1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)) ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |\r\t\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t\t"find min value in distanceFromStart dict"\r\t\t\tminValue := 10000000000000.\t"10 billion"\r\t\t\tdistanceFromStart\tkeysAndValuesDo: [ :key :value | \r\t\t\t\t\tTranscript crShow: (visited includes: key) not.\r\t\t\t\t\t((value < minValue) & ((visited includes: key) not))\tifTrue: [ \r\t\t\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\t\t\tminValue := value \r\t\t\t\t\t\t\t]\r\t\t\t\t\t\t ].\r\t\t\t"iterate through neighbors"\r\t\t\tneighbors := self\tgetFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)\tRobot: sketchRobot.\r\t\t\t1 to: neighbors size do: [ :i | \r\t\t\t\t| neighbor neighborPoint |\r\t\t\t\tneighbor := neighbors at: i.\r\t\t\t\tneighborPoint := Array newFrom: {neighbor location x. neighbor location y}.\r\t\t\t\t(grid includes: neighborPoint)ifTrue: [ | distance |\r\t\t\t\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t\t\t\t(distance < distanceFromStart at: neighborPoint) ifTrue: [ \r\t\t\t\t\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\t\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t] \r\t\t\t\t\t\t].\r\t\t\tvisited addLast: currentPoint.\r\t\t\tunVisited remove: currentPoint \r\t\t\t].\r\t\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.\t"1 billion"\r\tbestPath := OrderedCollection new.\r\t[ bestPath isEmpty ]\r\t\twhileTrue: [ 1 to: grid size do: [ :i | \r\t\t\t\t| point |\r\t\t\t\tpoint := grid at: i.\r\t\t\t\t(distanceFromStart at: point) < shortestPathLength\r\t\t\t\t\t& (point = startingPoint) not\r\t\t\t\t\tifTrue: [ "point is not equal to starting point"\r\t\t\t\t\t\t| path newPoint shouldBreak |\r\t\t\t\t\t\tpath := OrderedCollection new.\r\t\t\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\t\t\tpath addLast: point.\t"the point we are trying to is the first item since the list will be reversed"\r\t\t\t\t\t\tnewPoint := point.\t"initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\t\t\tshouldBreak := false.\r\t\t\t\t\t\t[ shouldBreak ]whileFalse:[\r\t\t\t\t\t\t\t newPoint := previousVertex at: newPoint.\t"get the previous point and add it to the list"\r\t\t\t\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t\t\t\tnewPoint = startingPoint\r\t\t\t\t\t\t\t\t\tifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t\t\t\t\tpath size > scanningRadius\r\t\t\t\t\t\t\t\t\t\t\tifTrue: [ shortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\t\t\t\t\t\tbestPath := path\t"this best path is only truly the best once the while loop has exited" ].\r\t\t\t\t\t\t\t\t\t\tshouldBreak := true ].\r\t\t\t\t\t\t\t\tpath size > (scanningRadius * 4)\r\t\t\t\t\t\t\t\t\tifTrue: [ shouldBreak := true \r\t\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t].\r\t\t\tscanningRadius := scanningRadius - 1 \r\t\t\t].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath',			#stamp : 'BenTran 2/6/2020 23:35',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:40:03.480348-05:00' ],		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'standardizePoint:Integer:Integer:Integer:',			#protocol : #'as yet unclassified',			#sourceCode : 'standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows\r\t"this will take a given coordinate and it wrap around the board"\r\t| newXPoint newYPoint |.\r\t\r\tnewXPoint := ((xPoint \\\\ columns) abs). "\\\\ is the same as % in python, coordinate system starts at 1,1 so we need to shift everything by 1"\r\tnewYPoint := ((yPoint \\\\ rows) abs).\r\t\r\t(xPoint = 0)ifTrue: [ \r\t\tnewXPoint := columns \r\t\t ].\r\t(yPoint = 0)ifTrue: [ \r\t\tnewYPoint := rows \r\t\t ].\r\t\r\t^ Array newFrom: {newXPoint . newYPoint}.\r\t\r\t',			#stamp : 'BenTran 2/6/2020 22:30',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'standardizePoint:Integer:Integer:Integer:',			#protocol : #'as yet unclassified',			#sourceCode : 'standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows\r\t"this will take a given coordinate and it wrap around the board"\r\t| newXPoint newYPoint |.\r\t\r\tnewXPoint := ((xPoint \\\\ columns) abs). "\\\\ is the same as % in python, coordinate system starts at 1,1 so we need to shift everything by 1"\r\tnewYPoint := ((yPoint \\\\ rows) abs).\r\t\r\t(xPoint = 0)ifTrue: [ \r\t\tnewXPoint := columns \r\t\t ].\r\t(newXPoint = 0)ifTrue: [ \r\t\tnewXPoint := columns \r\t\t ].\r\t(yPoint = 0)ifTrue: [ \r\t\tnewYPoint := rows \r\t\t ].\r\t(newYPoint = 0)ifTrue: [ \r\t\tnewYPoint := rows \r\t\t ].\r\t\r\t^ Array newFrom: {newXPoint . newYPoint}.\r\t\r\t',			#stamp : 'BenTran 2/6/2020 23:40',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:40:22.647348-05:00' ],		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tscanningRadius := depthDijkstra.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t1 to: scanningRadius * 2 + 1 do: [ :xCord | \r\t\t1 to: scanningRadius * 2 + 1 do: [ :yCord | \r\t\t\t| xPoint yPoint point |\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self\r\t\t\t\tstandardizePoint: xPoint\r\t\t\t\tInteger: yPoint\r\t\t\t\tInteger: sketchRobot map width\r\t\t\t\tInteger: sketchRobot map height.\r\t\t\t(grid includes: point) ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\t\tgrid addLast: point.\r\t\t\t\t\tpointsList\r\t\t\t\t\t\taddLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy \r\t\t\t\t\t\t] \r\t\t\t\t\t] \r\t\t\t\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom:{x . y}.\r\tdistanceFromStart := Dictionary new.\r\tpreviousVertex := Dictionary new.\r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: grid size do: [ :i | \r\t\t| point |\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.\t"1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)) ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |\r\t\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t\t"find min value in distanceFromStart dict"\r\t\t\tminValue := 10000000000000.\t"10 billion"\r\t\t\tdistanceFromStart\tkeysAndValuesDo: [ :key :value | \r\t\t\t\t\tTranscript crShow: (visited includes: key) not.\r\t\t\t\t\t((value < minValue) & ((visited includes: key) not))\tifTrue: [ \r\t\t\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\t\t\tminValue := value \r\t\t\t\t\t\t\t]\r\t\t\t\t\t\t ].\r\t\t\t"iterate through neighbors"\r\t\t\tneighbors := self\tgetFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)\tRobot: sketchRobot.\r\t\t\t1 to: neighbors size do: [ :i | \r\t\t\t\t| neighbor neighborPoint |\r\t\t\t\tneighbor := neighbors at: i.\r\t\t\t\tneighborPoint := Array newFrom: {neighbor location x. neighbor location y}.\r\t\t\t\t(grid includes: neighborPoint)ifTrue: [ | distance |\r\t\t\t\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t\t\t\t(distance < distanceFromStart at: neighborPoint) ifTrue: [ \r\t\t\t\t\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\t\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t] \r\t\t\t\t\t\t].\r\t\t\tvisited addLast: currentPoint.\r\t\t\tunVisited remove: currentPoint \r\t\t\t].\r\t\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.\t"1 billion"\r\tbestPath := OrderedCollection new.\r\t[ bestPath isEmpty ]\r\t\twhileTrue: [ 1 to: grid size do: [ :i | \r\t\t\t\t| point |\r\t\t\t\tpoint := grid at: i.\r\t\t\t\t(distanceFromStart at: point) < shortestPathLength\r\t\t\t\t\t& (point = startingPoint) not\r\t\t\t\t\tifTrue: [ "point is not equal to starting point"\r\t\t\t\t\t\t| path newPoint shouldBreak |\r\t\t\t\t\t\tpath := OrderedCollection new.\r\t\t\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\t\t\tpath addLast: point.\t"the point we are trying to is the first item since the list will be reversed"\r\t\t\t\t\t\tnewPoint := point.\t"initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\t\t\tshouldBreak := false.\r\t\t\t\t\t\t[ shouldBreak ]whileFalse:[\r\t\t\t\t\t\t\t newPoint := previousVertex at: newPoint.\t"get the previous point and add it to the list"\r\t\t\t\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t\t\t\tnewPoint = startingPoint\r\t\t\t\t\t\t\t\t\tifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t\t\t\t\tpath size > scanningRadius\r\t\t\t\t\t\t\t\t\t\t\tifTrue: [ shortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\t\t\t\t\t\tbestPath := path\t"this best path is only truly the best once the while loop has exited" ].\r\t\t\t\t\t\t\t\t\t\tshouldBreak := true ].\r\t\t\t\t\t\t\t\tpath size > (scanningRadius * 4)\r\t\t\t\t\t\t\t\t\tifTrue: [ shouldBreak := true \r\t\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t].\r\t\t\tscanningRadius := scanningRadius - 1 \r\t\t\t].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath',			#stamp : 'BenTran 2/6/2020 23:35',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tscanningRadius := depthDijkstra.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t1 to: scanningRadius * 2 + 1 do: [ :xCord | \r\t\t1 to: scanningRadius * 2 + 1 do: [ :yCord | \r\t\t\t| xPoint yPoint point |\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self\r\t\t\t\tstandardizePoint: xPoint\r\t\t\t\tInteger: yPoint\r\t\t\t\tInteger: sketchRobot map width\r\t\t\t\tInteger: sketchRobot map height.\r\t\t\t(grid includes: point) ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\t\tgrid addLast: point.\r\t\t\t\t\tpointsList\r\t\t\t\t\t\taddLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy \r\t\t\t\t\t\t] \r\t\t\t\t\t] \r\t\t\t\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom:{x . y}.\r\tdistanceFromStart := Dictionary new.\r\tpreviousVertex := Dictionary new.\r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: grid size do: [ :i | \r\t\t| point |\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.\t"1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)) ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |\r\t\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t\t"find min value in distanceFromStart dict"\r\t\t\tminValue := 10000000000000.\t"10 billion"\r\t\t\tdistanceFromStart\tkeysAndValuesDo: [ :key :value | \r\t\t\t\t\t((value < minValue) & ((visited includes: key) not))\tifTrue: [ \r\t\t\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\t\t\tminValue := value \r\t\t\t\t\t\t\t]\r\t\t\t\t\t\t ].\r\t\t\t"iterate through neighbors"\r\t\t\tneighbors := self\tgetFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)\tRobot: sketchRobot.\r\t\t\t1 to: neighbors size do: [ :i | \r\t\t\t\t| neighbor neighborPoint |\r\t\t\t\tneighbor := neighbors at: i.\r\t\t\t\tneighborPoint := Array newFrom: {neighbor location x. neighbor location y}.\r\t\t\t\t(grid includes: neighborPoint)ifTrue: [ | distance |\r\t\t\t\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t\t\t\t(distance < distanceFromStart at: neighborPoint) ifTrue: [ \r\t\t\t\t\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\t\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t] \r\t\t\t\t\t\t].\r\t\t\tvisited addLast: currentPoint.\r\t\t\tunVisited remove: currentPoint \r\t\t\t].\r\t\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.\t"1 billion"\r\tbestPath := OrderedCollection new.\r\t[ bestPath isEmpty ]\r\t\twhileTrue: [ 1 to: grid size do: [ :i | \r\t\t\t\t| point |\r\t\t\t\tpoint := grid at: i.\r\t\t\t\t(distanceFromStart at: point) < shortestPathLength\r\t\t\t\t\t& (point = startingPoint) not\r\t\t\t\t\tifTrue: [ "point is not equal to starting point"\r\t\t\t\t\t\t| path newPoint shouldBreak |\r\t\t\t\t\t\tpath := OrderedCollection new.\r\t\t\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\t\t\tpath addLast: point.\t"the point we are trying to is the first item since the list will be reversed"\r\t\t\t\t\t\tnewPoint := point.\t"initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\t\t\tshouldBreak := false.\r\t\t\t\t\t\t[ shouldBreak ]whileFalse:[\r\t\t\t\t\t\t\t newPoint := previousVertex at: newPoint.\t"get the previous point and add it to the list"\r\t\t\t\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t\t\t\tnewPoint = startingPoint\r\t\t\t\t\t\t\t\t\tifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t\t\t\t\tpath size > scanningRadius\r\t\t\t\t\t\t\t\t\t\t\tifTrue: [ shortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\t\t\t\t\t\tbestPath := path\t"this best path is only truly the best once the while loop has exited" ].\r\t\t\t\t\t\t\t\t\t\tshouldBreak := true ].\r\t\t\t\t\t\t\t\tpath size > (scanningRadius * 4)\r\t\t\t\t\t\t\t\t\tifTrue: [ shouldBreak := true \r\t\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t].\r\t\t\tscanningRadius := scanningRadius - 1 \r\t\t\t].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath',			#stamp : 'BenTran 2/6/2020 23:40',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:41:38.341348-05:00' ],		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tdepthDijkstra := 3.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 23:20',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tdepthDijkstra := 5.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 23:41',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:43:05.165348-05:00' ],		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tscanningRadius := depthDijkstra.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t1 to: scanningRadius * 2 + 1 do: [ :xCord | \r\t\t1 to: scanningRadius * 2 + 1 do: [ :yCord | \r\t\t\t| xPoint yPoint point |\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self\r\t\t\t\tstandardizePoint: xPoint\r\t\t\t\tInteger: yPoint\r\t\t\t\tInteger: sketchRobot map width\r\t\t\t\tInteger: sketchRobot map height.\r\t\t\t(grid includes: point) ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\t\tgrid addLast: point.\r\t\t\t\t\tpointsList\r\t\t\t\t\t\taddLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy \r\t\t\t\t\t\t] \r\t\t\t\t\t] \r\t\t\t\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom:{x . y}.\r\tdistanceFromStart := Dictionary new.\r\tpreviousVertex := Dictionary new.\r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: grid size do: [ :i | \r\t\t| point |\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.\t"1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)) ].\r\tdistanceFromStart at: startingPoint put: 0.\r\tTranscript crShow: grid.\r\tTranscript crShow: grid size.\r\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |\r\t\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t\t"find min value in distanceFromStart dict"\r\t\t\tminValue := 10000000000000.\t"10 billion"\r\t\t\tdistanceFromStart\tkeysAndValuesDo: [ :key :value | \r\t\t\t\t\t((value < minValue) & ((visited includes: key) not))\tifTrue: [ \r\t\t\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\t\t\tminValue := value \r\t\t\t\t\t\t\t]\r\t\t\t\t\t\t ].\r\t\t\t"iterate through neighbors"\r\t\t\tneighbors := self\tgetFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)\tRobot: sketchRobot.\r\t\t\t1 to: neighbors size do: [ :i | \r\t\t\t\t| neighbor neighborPoint |\r\t\t\t\tneighbor := neighbors at: i.\r\t\t\t\tneighborPoint := Array newFrom: {neighbor location x. neighbor location y}.\r\t\t\t\t(grid includes: neighborPoint)ifTrue: [ | distance |\r\t\t\t\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t\t\t\t(distance < distanceFromStart at: neighborPoint) ifTrue: [ \r\t\t\t\t\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\t\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t] \r\t\t\t\t\t\t].\r\t\t\tvisited addLast: currentPoint.\r\t\t\tunVisited remove: currentPoint \r\t\t\t].\r\t\t\r\tTranscript crShow: distanceFromStart.\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.\t"1 billion"\r\tbestPath := OrderedCollection new.\r\t[ bestPath isEmpty ]\r\t\twhileTrue: [ 1 to: grid size do: [ :i | \r\t\t\t\t| point |\r\t\t\t\tpoint := grid at: i.\r\t\t\t\t(distanceFromStart at: point) < shortestPathLength\r\t\t\t\t\t& (point = startingPoint) not\r\t\t\t\t\tifTrue: [ "point is not equal to starting point"\r\t\t\t\t\t\t| path newPoint shouldBreak |\r\t\t\t\t\t\tpath := OrderedCollection new.\r\t\t\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\t\t\tpath addLast: point.\t"the point we are trying to is the first item since the list will be reversed"\r\t\t\t\t\t\tnewPoint := point.\t"initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\t\t\tshouldBreak := false.\r\t\t\t\t\t\t[ shouldBreak ]whileFalse:[\r\t\t\t\t\t\t\t newPoint := previousVertex at: newPoint.\t"get the previous point and add it to the list"\r\t\t\t\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t\t\t\tnewPoint = startingPoint\r\t\t\t\t\t\t\t\t\tifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t\t\t\t\tpath size > scanningRadius\r\t\t\t\t\t\t\t\t\t\t\tifTrue: [ shortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\t\t\t\t\t\tbestPath := path\t"this best path is only truly the best once the while loop has exited" ].\r\t\t\t\t\t\t\t\t\t\tshouldBreak := true ].\r\t\t\t\t\t\t\t\tpath size > (scanningRadius * 4)\r\t\t\t\t\t\t\t\t\tifTrue: [ shouldBreak := true \r\t\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t].\r\t\t\tscanningRadius := scanningRadius - 1 \r\t\t\t].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath',			#stamp : 'BenTran 2/6/2020 23:40',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #'Dijkstra:',			#protocol : #'as yet unclassified',			#sourceCode : 'Dijkstra: sketchRobot\r\t"create a new list of all points within the robots scanning radius ----------------------------------------"\r\r\t| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |\r\tTranscript crShow: \'Dijkstra HAS BEEN CALLED -----------------------------------------------------\'.\r\tscanningRadius := depthDijkstra.\r\tgrid := OrderedCollection new.\r\tpointsList := OrderedCollection new.\r\tx := sketchRobot location x.\r\ty := sketchRobot location y.\r\t1 to: scanningRadius * 2 + 1 do: [ :xCord | \r\t\t1 to: scanningRadius * 2 + 1 do: [ :yCord | \r\t\t\t| xPoint yPoint point |\r\t\t\txPoint := x - scanningRadius + xCord.\r\t\t\tyPoint := y - scanningRadius + yCord.\r\t\t\t"this will take a given coordinate and it wrap around the board"\r\t\t\tpoint := self\r\t\t\t\tstandardizePoint: xPoint\r\t\t\t\tInteger: yPoint\r\t\t\t\tInteger: sketchRobot map width\r\t\t\t\tInteger: sketchRobot map height.\r\t\t\t(grid includes: point) ifFalse: [ "sometimes you get repeats because of the point standardization"\r\t\t\t\t\tgrid addLast: point.\r\t\t\t\t\tpointsList\r\t\t\t\t\t\taddLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy \r\t\t\t\t\t\t] \r\t\t\t\t\t] \r\t\t\t\t].\r\r\t"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"\r\t"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"\r\thighestPoint := pointsList max.\r\tstartingPoint := Array newFrom:{x . y}.\r\tdistanceFromStart := Dictionary new.\r\tpreviousVertex := Dictionary new.\r\tvisited := OrderedCollection new.\r\tunVisited := grid copy.\r\tTranscript crShow: \'STARTING POINT\'.\r\tTranscript show: startingPoint.\r\r\t" set all distances to infinity and initlize previous distance dict with default keys"\r\t1 to: grid size do: [ :i | \r\t\t| point |\r\t\tpoint := grid at: i.\r\t\tdistanceFromStart at: point put: 1000000000000.\t"1 billion, number must be very large because distance from starting point to all other points is unkown at this point"\r\t\tpreviousVertex at: point put: (Array newFrom: #(-1 -1)) ].\r\tdistanceFromStart at: startingPoint put: 0.\r\r\t"point visit loop --------------------------------------------------------------------------------------------"\r\t[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |\r\t\t\tcurrentPoint := Array newFrom: #(-1 -1).\r\t\t\t"find min value in distanceFromStart dict"\r\t\t\tminValue := 10000000000000.\t"10 billion"\r\t\t\tdistanceFromStart\tkeysAndValuesDo: [ :key :value | \r\t\t\t\t\t((value < minValue) & ((visited includes: key) not))\tifTrue: [ \r\t\t\t\t\t\t\tcurrentPoint := key.\r\t\t\t\t\t\t\tminValue := value \r\t\t\t\t\t\t\t]\r\t\t\t\t\t\t ].\r\t\t\t"iterate through neighbors"\r\t\t\tneighbors := self\tgetFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)\tRobot: sketchRobot.\r\t\t\t1 to: neighbors size do: [ :i | \r\t\t\t\t| neighbor neighborPoint |\r\t\t\t\tneighbor := neighbors at: i.\r\t\t\t\tneighborPoint := Array newFrom: {neighbor location x. neighbor location y}.\r\t\t\t\t(grid includes: neighborPoint)ifTrue: [ | distance |\r\t\t\t\t\t\tdistance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).\r\t\t\t\t\t\t(distance < distanceFromStart at: neighborPoint) ifTrue: [ \r\t\t\t\t\t\t\t\tdistanceFromStart at: neighborPoint put: distance.\r\t\t\t\t\t\t\t\tpreviousVertex at: neighborPoint put: currentPoint \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t] \r\t\t\t\t\t\t].\r\t\t\tvisited addLast: currentPoint.\r\t\t\tunVisited remove: currentPoint \r\t\t\t].\r\t\t\r\t"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"\r\tshortestPathLength := 1000000000000.\t"1 billion"\r\tbestPath := OrderedCollection new.\r\t[ bestPath isEmpty ]\r\t\twhileTrue: [ 1 to: grid size do: [ :i | \r\t\t\t\t| point |\r\t\t\t\tpoint := grid at: i.\r\t\t\t\t(distanceFromStart at: point) < shortestPathLength\r\t\t\t\t\t& (point = startingPoint) not\r\t\t\t\t\tifTrue: [ "point is not equal to starting point"\r\t\t\t\t\t\t| path newPoint shouldBreak |\r\t\t\t\t\t\tpath := OrderedCollection new.\r\t\t\t\t\t\t"work backwards from best point to find optimal path"\r\t\t\t\t\t\tpath addLast: point.\t"the point we are trying to is the first item since the list will be reversed"\r\t\t\t\t\t\tnewPoint := point.\t"initialize newPoint w since this will be reassigned in the while loop"\r\t\t\t\t\t\tshouldBreak := false.\r\t\t\t\t\t\t[ shouldBreak ]whileFalse:[\r\t\t\t\t\t\t\t newPoint := previousVertex at: newPoint.\t"get the previous point and add it to the list"\r\t\t\t\t\t\t\t\tpath addLast: newPoint.\r\t\t\t\t\t\t\t\tnewPoint = startingPoint\r\t\t\t\t\t\t\t\t\tifTrue: [ "if the starting point is equal to current point we found a path"\r\t\t\t\t\t\t\t\t\t\t"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"\r\t\t\t\t\t\t\t\t\t\tpath size > scanningRadius\r\t\t\t\t\t\t\t\t\t\t\tifTrue: [ shortestPathLength := distanceFromStart at: point.\r\t\t\t\t\t\t\t\t\t\t\t\tbestPath := path\t"this best path is only truly the best once the while loop has exited" ].\r\t\t\t\t\t\t\t\t\t\tshouldBreak := true ].\r\t\t\t\t\t\t\t\tpath size > (scanningRadius * 4)\r\t\t\t\t\t\t\t\t\tifTrue: [ shouldBreak := true \r\t\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t\t] \r\t\t\t\t\t\t\t].\r\t\t\tscanningRadius := scanningRadius - 1 \r\t\t\t].\r\tbestPath removeLast.\r\tbestPath := bestPath reversed.\r\tdirectionList := bestPath',			#stamp : 'BenTran 2/6/2020 23:43',			#package : #JRMPC-Phase1-Minds		}	}}OmEntry {	#tags : {		#author : 'BenTran',		#time : DateAndTime [ '2020-02-06T23:45:37.402348-05:00' ],		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tdepthDijkstra := 5.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 23:41',			#package : #JRMPC-Phase1-Minds		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RobotMind,				#isMetaSide : false			},			#name : #initialize,			#protocol : #running,			#sourceCode : 'initialize \r\n\t"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.\r\n\t This method is not part of the competition API, but a standard part of Pharo\r\n\t called when objects are instatiated."\r\tdoesYellowSquareExist := false.\r\thighestPointSquares := OrderedCollection new. \r\tdepthNN := 3. "number of layers deep that the NN should look at"\r\tdepthDijkstra := 4.\r\tcurrentX := 0.\r\tcurrentY := 0.\r\tdirectionList := OrderedCollection new.\r\n\tsuper initialize',			#stamp : 'BenTran 2/6/2020 23:45',			#package : #JRMPC-Phase1-Minds		}	}}