[31mSubscriptOutOfBounds: 1
[0mArray(Object)>>errorSubscriptBounds:
Array(Object)>>at:put:
MyTeamMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#direction was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #direction
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mArray(Object)>>errorSubscriptBounds:
Array(Object)>>at:put:
BestNeighborMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#direction was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #direction
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mArray(Object)>>errorSubscriptBounds:
Array(Object)>>at:put:
MyTeamMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#direction was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #direction
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mArray(Object)>>errorSubscriptBounds:
Array(Object)>>at:put:
BestNeighborMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#direction was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #direction
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mArray(Object)>>errorSubscriptBounds:
Array(Object)>>at:put:
MyTeamMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of OrderedCollection class are not indexable
[0mOrderedCollection class(Object)>>error:
OrderedCollection class(Object)>>errorNotIndexable
OrderedCollection class(Object)>>at:put:
BestNeighborMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of OrderedCollection class did not understand #add:
[0mOrderedCollection class(Object)>>doesNotUnderstand: #add:
BestNeighborMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0mr  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m