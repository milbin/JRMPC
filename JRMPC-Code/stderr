[31mInstance of SmallInteger did not understand #rem
[0mSmallInteger(Object)>>doesNotUnderstand: #rem
MyTeamMind(RobotMind)>>standardizePoint:Integer:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #rem
[0mSmallInteger(Object)>>doesNotUnderstand: #rem
MyTeamMind(RobotMind)>>standardizePoint:Integer:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of True did not understand #whileTrue:
[0mTrue(Object)>>doesNotUnderstand: #whileTrue:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(2 3) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(2 3) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of False did not understand #whileFalse:
[0mFalse(Object)>>doesNotUnderstand: #whileFalse:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(3 3) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(3 3) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display,[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In [31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow:[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ sel[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | rob[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFi[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With [31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running [31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following exe[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldStat[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following [31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealT[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact o[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped b[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"T[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcess[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on displ[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real [31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProc[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #(-1 -1) not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 1
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
OrderedCollection(SequenceableCollection)>>anyOne
OrderedCollection(Collection)>>max
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(3 3) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(6 1) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(6 1) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(6 1) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(6 1) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(6 1) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(5 20) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(5 20) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(5 20) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: #(5 20) not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
MyTeamMind(RobotMind)>>Dijkstra:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m