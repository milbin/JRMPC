[31mHalt
[0mRobot(Object)>>halt
Robot>>navigator
Robot>>moveLeft
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mHalt
[0mRobot(Object)>>halt
Robot>>navigator
Robot>>moveLeft
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mHalt
[0mRobot(Object)>>halt
Robot>>navigator
Robot>>moveLeft
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[31mHalt
[0mRobot(Object)>>halt
Robot>>navigator
Robot>>moveLeft
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mHalt
[0mRobot(Object)>>halt
Robot>>navigator
Robot>>moveLeft
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 0
[0mOrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:put:
Dictionary>>at:at:put:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Dictionary did not understand #at:add:
[0mDictionary(Object)>>doesNotUnderstand: #at:add:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Dictionary did not understand #at:add:
[0mDictionary(Object)>>doesNotUnderstand: #at:add:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Dictionary did not understand #at:add:
[0mDictionary(Object)>>doesNotUnderstand: #at:add:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Dictionary did not understand #at:add:
[0mDictionary(Object)>>doesNotUnderstand: #at:add:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of True did not understand #whileTrue:
[0mTrue(Object)>>doesNotUnderstand: #whileTrue:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of True did not understand #whileTrue:
[0mTrue(Object)>>doesNotUnderstand: #whileTrue:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of True did not understand #whileTrue:
[0mTrue(Object)>>doesNotUnderstand: #whileTrue:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Array did not understand #length
[0mArray(Object)>>doesNotUnderstand: #length
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Array did not understand #length
[0mArray(Object)>>doesNotUnderstand: #length
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Array did not understand #length
[0mArray(Object)>>doesNotUnderstand: #length
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #y
[0mSmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin: in Block: [ self mindDoOneCycle: sketchRobot ]
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ :robot | robot determineDirectionWithin: stepTim...etc...
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ self isFinished...
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop in Block: [ [ self isFinished...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m