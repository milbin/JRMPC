THERE_BE_DRAGONS_HERE
Instance of ZnBufferedWriteStream did not understand #name
29 January 2020 3:18:45.578906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

ZnBufferedWriteStream(Object)>>doesNotUnderstand: #name
	Receiver: a ZnBufferedWriteStream
	Arguments and temporary variables: 
		aMessage: 	name
		exception: 	MessageNotUnderstood: ZnBufferedWriteStream>>name
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	BinaryFileStream: 'C:\Users\mlbbe\Downloads\pharo-launcher-1.9.2.msi'
		buffer: 	nil
		position: 	0


DefaultExternalDropHandler>>handle:in:dropEvent:
	Receiver: a DefaultExternalDropHandler
	Arguments and temporary variables: 
		dropStream: 	a ZnBufferedWriteStream
		pasteUp: 	a WorldMorph(479349760) [world]
		anEvent: 	[(886@193) dropFilesEvent nil]
		fileName: 	nil
		services: 	nil
		theOne: 	nil
	Receiver's instance variables: 
a DefaultExternalDropHandler

[ :stream | handler handle: stream in: self dropEvent: anEvent ] in WorldMorph(PasteUpMorph)>>dropFiles:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		numFiles: 	1
		i: 	1
		aFileReference: 	File @ C:\Users\mlbbe\Downloads\pharo-launcher-1.9.2.msi
		handler: 	a DefaultExternalDropHandler
		stream: 	a ZnBufferedWriteStream
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


[ aBlock value: stream ] in FileReference(AbstractFileReference)>>binaryWriteStreamDo:
	Receiver: File @ C:\Users\mlbbe\Downloads\pharo-launcher-1.9.2.msi
	Arguments and temporary variables: 
		aBlock: 	[ :stream | handler handle: stream in: self dropEvent: anEvent ]
		stream: 	a ZnBufferedWriteStream
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'C:' / 'Users' / 'mlbbe' / 'Downloads' / 'pharo-launcher-1.9.2.msi...etc...


BlockClosure>>ensure:
	Receiver: [ aBlock value: stream ]
	Arguments and temporary variables: 
		aBlock: 	[ stream close ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	FileReference(AbstractFileReference)>>binaryWriteStreamDo:
		startpc: 	58
		numArgs: 	0


FileReference(AbstractFileReference)>>binaryWriteStreamDo:
	Receiver: File @ C:\Users\mlbbe\Downloads\pharo-launcher-1.9.2.msi
	Arguments and temporary variables: 
		aBlock: 	[ :stream | handler handle: stream in: self dropEvent: anEvent ]
		stream: 	a ZnBufferedWriteStream
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'C:' / 'Users' / 'mlbbe' / 'Downloads' / 'pharo-launcher-1.9.2.msi...etc...


WorldMorph(PasteUpMorph)>>dropFiles:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		numFiles: 	1
		i: 	1
		aFileReference: 	File @ C:\Users\mlbbe\Downloads\pharo-launcher-1.9.2.msi
		handler: 	a DefaultExternalDropHandler
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph(Morph)>>handleDropFiles:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


DropFilesEvent>>sentTo:
	Receiver: [(886@193) dropFilesEvent nil]
	Arguments and temporary variables: 
		anObject: 	a WorldMorph(479349760) [world]
	Receiver's instance variables: 
		timeStamp: 	nil
		source: 	a HandMorph(454097152)
		windowIndex: 	nil
		position: 	(886@193)
		contents: 	1
		wasHandled: 	true


WorldMorph(Morph)>>handleEvent:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		aMorph: 	a WorldMorph(479349760) [world]
		localEvt: 	[(886@193) dropFilesEvent nil]
		index: 	4
		child: 	an ImageMorph(47910656)
		morphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an ImageMo...etc...
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleDropFiles:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
	Receiver's instance variables: 
		morph: 	nil


DropFilesEvent>>sentTo:
	Receiver: [(886@193) dropFilesEvent nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	nil
		source: 	a HandMorph(454097152)
		windowIndex: 	nil
		position: 	(886@193)
		contents: 	1
		wasHandled: 	true


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		aMorph: 	a WorldMorph(479349760) [world]
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		aMorph: 	a WorldMorph(479349760) [world]
	Receiver's instance variables: 
		morph: 	nil


WorldMorph(Morph)>>processEvent:using:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph(Morph)>>processEvent:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(454097152)
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		focusHolder: 	nil
		aBlock: 	[ nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(203@506) corner: (219@522)
		owner: 	a WorldMorph(479349760) [world]
		submorphs: 	#()
		fullBounds: 	(203@506) corner: (219@522)
		color: 	Color blue
		extension: 	nil
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(783971328)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(203@506) mouseOver 15219093 nil]
		targetOffset: 	(477@198)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15219093 188 545 0 0 0 1)
		lastKeyScanCode: 	nil
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:
	Receiver: a HandMorph(454097152)
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		focusHolder: 	nil
	Receiver's instance variables: 
		bounds: 	(203@506) corner: (219@522)
		owner: 	a WorldMorph(479349760) [world]
		submorphs: 	#()
		fullBounds: 	(203@506) corner: (219@522)
		color: 	Color blue
		extension: 	nil
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(783971328)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(203@506) mouseOver 15219093 nil]
		targetOffset: 	(477@198)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15219093 188 545 0 0 0 1)
		lastKeyScanCode: 	nil
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(454097152)
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		evt: 	[(886@193) dropFilesEvent nil]
	Receiver's instance variables: 
		bounds: 	(203@506) corner: (219@522)
		owner: 	a WorldMorph(479349760) [world]
		submorphs: 	#()
		fullBounds: 	(203@506) corner: (219@522)
		color: 	Color blue
		extension: 	nil
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(783971328)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(203@506) mouseOver 15219093 nil]
		targetOffset: 	(477@198)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15219093 188 545 0 0 0 1)
		lastKeyScanCode: 	nil
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEventsFromQueue:
	Receiver: a HandMorph(454097152)
	Arguments and temporary variables: 
		anEventQueue: 	an InputEventSensor
		evt: 	[(886@193) dropFilesEvent nil]
		evtBuf: 	#(3 24460 4 886 193 0 1 1)
		type: 	3
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(203@506) corner: (219@522)
		owner: 	a WorldMorph(479349760) [world]
		submorphs: 	#()
		fullBounds: 	(203@506) corner: (219@522)
		color: 	Color blue
		extension: 	nil
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(783971328)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(203@506) mouseOver 15219093 nil]
		targetOffset: 	(477@198)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15219093 188 545 0 0 0 1)
		lastKeyScanCode: 	nil
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(454097152)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(203@506) corner: (219@522)
		owner: 	a WorldMorph(479349760) [world]
		submorphs: 	#()
		fullBounds: 	(203@506) corner: (219@522)
		color: 	Color blue
		extension: 	nil
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(783971328)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(203@506) mouseOver 15219093 nil]
		targetOffset: 	(477@198)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15219093 188 545 0 0 0 1)
		lastKeyScanCode: 	nil
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(479349760) [world]
		h: 	a HandMorph(454097152)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(454097152))
		viewBox: 	(0@0) corner: (976@665)
		canvas: 	a FormCanvas on: DisplayScreen(976x665x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	17034
		lastStepMessage: 	nil
		lastCycleTime: 	24473
		alarms: 	a Heap()
		lastAlarmTime: 	24448
		menuBuilder: 	nil
		activeHand: 	a HandMorph(454097152)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(454097152))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(454097152))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(454097152))
		viewBox: 	(0@0) corner: (976@665)
		canvas: 	a FormCanvas on: DisplayScreen(976x665x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	17034
		lastStepMessage: 	nil
		lastCycleTime: 	24473
		alarms: 	a Heap()
		lastAlarmTime: 	24448
		menuBuilder: 	nil
		activeHand: 	a HandMorph(454097152)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(479349760) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(454097152))
		viewBox: 	(0@0) corner: (976@665)
		canvas: 	a FormCanvas on: DispTHERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
29 January 2020 3:42:46.916906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(211988224))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(211988224))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 37 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 29 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(211988224))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContTHERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:42:47.006906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(211988224))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds -THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
29 January 2020 3:43:46.558906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(955805440))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(955805440))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 32 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 27 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(955805440))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


THERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:43:46.657906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(955805440))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
29 January 2020 3:44:54.694906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(156600576))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(156600576))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so .THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
29 January 2020 3:52:27.125906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1042046720))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1042046720))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 21 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 15 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1042046720))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so deTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 3:52:59.100906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(517725952))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(517725952))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 44 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 40 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(517725952))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:put:
MyTeamMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completionTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 3:54:08.450906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(413563136))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(413563136))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 11 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 7 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(413563136))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProTHERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:54:08.574906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(413563136))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStoppTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 3:56:02.483906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	3000
	Receiver's instance variables: 
#()

BestNeighborMind(RobotMind)>>setupOn:
	Receiver: a BestNeighborMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(907370240))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(907370240))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 54 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 50 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(907370240))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous THERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:56:02.652906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(907370240))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't wTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 3:56:47.236887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


THERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:56:47.285887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 3:56:52.751887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	3000
	Receiver's instance variables: 
#()

BestNeighborMind(RobotMind)>>setupOn:
	Receiver: a BestNeighborMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 61 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 47 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an AnnouncerTHERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:56:52.856887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #direction
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 4:01:48.396887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	73
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(13@30)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	7
		x: 	29
		energyValue: 	73
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(686132992))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(686132992))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 52 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 47 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(686132992))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(13@30)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(13@30)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:put:
MyTeamMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		selfTHERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 4:01:48.504887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(686132992))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(13@30)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(13@30)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #direction
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on diTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 4:02:11.235887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	75
	Receiver's instance variables: 
#()

BestNeighborMind(RobotMind)>>setupOn:
	Receiver: a BestNeighborMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	14
		x: 	10
		energyValue: 	75
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1071521536))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1071521536))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 59 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 54 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1071521536))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
	THERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 4:02:11.339887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1071521536))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #direction
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, theTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 4:07:29.480887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	75
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	14
		x: 	10
		energyValue: 	75
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(555345664))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(555345664))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 51 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 47 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(555345664))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't wanTHERE_BE_DRAGONS_HERE
Error: Instances of OrderedCollection class are not indexable
29 January 2020 4:15:11.095887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

OrderedCollection class(Object)>>error:
	Receiver: OrderedCollection
	Arguments and temporary variables: 
		aString: 	'Instances of OrderedCollection class are not indexable'
	Receiver's instance variables: 
		superclass: 	SequenceableCollection
		methodDict: 	a MethodDictionary(#add:->OrderedCollection>>#add: #add:after:->Ord...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection...etc...
		name: 	#OrderedCollection
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable-Ordered'


OrderedCollection class(Object)>>errorNotIndexable
	Receiver: OrderedCollection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	SequenceableCollection
		methodDict: 	a MethodDictionary(#add:->OrderedCollection>>#add: #add:after:->Ord...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection...etc...
		name: 	#OrderedCollection
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable-Ordered'


OrderedCollection class(Object)>>at:put:
	Receiver: OrderedCollection
	Arguments and temporary variables: 
		index: 	1
		value: 	93
	Receiver's instance variables: 
		superclass: 	SequenceableCollection
		methodDict: 	a MethodDictionary(#add:->OrderedCollection>>#add: #add:after:->Ord...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection...etc...
		name: 	#OrderedCollection
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable-Ordered'


BestNeighborMind(RobotMind)>>setupOn:
	Receiver: a BestNeighborMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(13@30)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	8
		x: 	28
		energyValue: 	93
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		highestPointSquares: 	OrderedCollection


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(718558464))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(718558464))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 41 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 34 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(718558464))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(13@30)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(13@30)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
OrderedCollection class(Object)>>error:
OrderedCollection class(Object)>>errorNotIndexable
OrderedCollection class(Object)>>at:put:
BestNeighborMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce:THERE_BE_DRAGONS_HERE
Instance of OrderedCollection class did not understand #add:
29 January 2020 4:16:21.576887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

OrderedCollection class(Object)>>doesNotUnderstand: #add:
	Receiver: OrderedCollection
	Arguments and temporary variables: 
		aMessage: 	add: 93
		exception: 	MessageNotUnderstood: OrderedCollection class>>add:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	SequenceableCollection
		methodDict: 	a MethodDictionary(#add:->OrderedCollection>>#add: #add:after:->Ord...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection...etc...
		name: 	#OrderedCollection
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable-Ordered'


BestNeighborMind(RobotMind)>>setupOn:
	Receiver: a BestNeighborMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(13@30)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	8
		x: 	28
		energyValue: 	93
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		highestPointSquares: 	OrderedCollection


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(31143424))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(31143424))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 53 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 48 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(31143424))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(13@30)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(13@30)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
OrderedCollection class(Object)>>doesNotUnderstand: #add:
BestNeighborMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to r