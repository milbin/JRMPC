THERE_BE_DRAGONS_HERE
Instance of ZnBufferedWriteStream did not understand #name
29 January 2020 3:18:45.578906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

ZnBufferedWriteStream(Object)>>doesNotUnderstand: #name
	Receiver: a ZnBufferedWriteStream
	Arguments and temporary variables: 
		aMessage: 	name
		exception: 	MessageNotUnderstood: ZnBufferedWriteStream>>name
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	BinaryFileStream: 'C:\Users\mlbbe\Downloads\pharo-launcher-1.9.2.msi'
		buffer: 	nil
		position: 	0


DefaultExternalDropHandler>>handle:in:dropEvent:
	Receiver: a DefaultExternalDropHandler
	Arguments and temporary variables: 
		dropStream: 	a ZnBufferedWriteStream
		pasteUp: 	a WorldMorph(479349760) [world]
		anEvent: 	[(886@193) dropFilesEvent nil]
		fileName: 	nil
		services: 	nil
		theOne: 	nil
	Receiver's instance variables: 
a DefaultExternalDropHandler

[ :stream | handler handle: stream in: self dropEvent: anEvent ] in WorldMorph(PasteUpMorph)>>dropFiles:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		numFiles: 	1
		i: 	1
		aFileReference: 	File @ C:\Users\mlbbe\Downloads\pharo-launcher-1.9.2.msi
		handler: 	a DefaultExternalDropHandler
		stream: 	a ZnBufferedWriteStream
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


[ aBlock value: stream ] in FileReference(AbstractFileReference)>>binaryWriteStreamDo:
	Receiver: File @ C:\Users\mlbbe\Downloads\pharo-launcher-1.9.2.msi
	Arguments and temporary variables: 
		aBlock: 	[ :stream | handler handle: stream in: self dropEvent: anEvent ]
		stream: 	a ZnBufferedWriteStream
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'C:' / 'Users' / 'mlbbe' / 'Downloads' / 'pharo-launcher-1.9.2.msi...etc...


BlockClosure>>ensure:
	Receiver: [ aBlock value: stream ]
	Arguments and temporary variables: 
		aBlock: 	[ stream close ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	FileReference(AbstractFileReference)>>binaryWriteStreamDo:
		startpc: 	58
		numArgs: 	0


FileReference(AbstractFileReference)>>binaryWriteStreamDo:
	Receiver: File @ C:\Users\mlbbe\Downloads\pharo-launcher-1.9.2.msi
	Arguments and temporary variables: 
		aBlock: 	[ :stream | handler handle: stream in: self dropEvent: anEvent ]
		stream: 	a ZnBufferedWriteStream
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'C:' / 'Users' / 'mlbbe' / 'Downloads' / 'pharo-launcher-1.9.2.msi...etc...


WorldMorph(PasteUpMorph)>>dropFiles:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		numFiles: 	1
		i: 	1
		aFileReference: 	File @ C:\Users\mlbbe\Downloads\pharo-launcher-1.9.2.msi
		handler: 	a DefaultExternalDropHandler
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph(Morph)>>handleDropFiles:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


DropFilesEvent>>sentTo:
	Receiver: [(886@193) dropFilesEvent nil]
	Arguments and temporary variables: 
		anObject: 	a WorldMorph(479349760) [world]
	Receiver's instance variables: 
		timeStamp: 	nil
		source: 	a HandMorph(454097152)
		windowIndex: 	nil
		position: 	(886@193)
		contents: 	1
		wasHandled: 	true


WorldMorph(Morph)>>handleEvent:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		aMorph: 	a WorldMorph(479349760) [world]
		localEvt: 	[(886@193) dropFilesEvent nil]
		index: 	4
		child: 	an ImageMorph(47910656)
		morphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an ImageMo...etc...
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleDropFiles:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
	Receiver's instance variables: 
		morph: 	nil


DropFilesEvent>>sentTo:
	Receiver: [(886@193) dropFilesEvent nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	nil
		source: 	a HandMorph(454097152)
		windowIndex: 	nil
		position: 	(886@193)
		contents: 	1
		wasHandled: 	true


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		aMorph: 	a WorldMorph(479349760) [world]
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		aMorph: 	a WorldMorph(479349760) [world]
	Receiver's instance variables: 
		morph: 	nil


WorldMorph(Morph)>>processEvent:using:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph(Morph)>>processEvent:
	Receiver: a WorldMorph(479349760) [world]
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(783971328) a TaskbarMorph(733536000) an Imag...etc...
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (668403968) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.705 g: 0.705 b: 0.705 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(454097152)
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		focusHolder: 	nil
		aBlock: 	[ nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(203@506) corner: (219@522)
		owner: 	a WorldMorph(479349760) [world]
		submorphs: 	#()
		fullBounds: 	(203@506) corner: (219@522)
		color: 	Color blue
		extension: 	nil
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(783971328)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(203@506) mouseOver 15219093 nil]
		targetOffset: 	(477@198)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15219093 188 545 0 0 0 1)
		lastKeyScanCode: 	nil
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:
	Receiver: a HandMorph(454097152)
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		focusHolder: 	nil
	Receiver's instance variables: 
		bounds: 	(203@506) corner: (219@522)
		owner: 	a WorldMorph(479349760) [world]
		submorphs: 	#()
		fullBounds: 	(203@506) corner: (219@522)
		color: 	Color blue
		extension: 	nil
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(783971328)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(203@506) mouseOver 15219093 nil]
		targetOffset: 	(477@198)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15219093 188 545 0 0 0 1)
		lastKeyScanCode: 	nil
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(454097152)
	Arguments and temporary variables: 
		anEvent: 	[(886@193) dropFilesEvent nil]
		evt: 	[(886@193) dropFilesEvent nil]
	Receiver's instance variables: 
		bounds: 	(203@506) corner: (219@522)
		owner: 	a WorldMorph(479349760) [world]
		submorphs: 	#()
		fullBounds: 	(203@506) corner: (219@522)
		color: 	Color blue
		extension: 	nil
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(783971328)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(203@506) mouseOver 15219093 nil]
		targetOffset: 	(477@198)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15219093 188 545 0 0 0 1)
		lastKeyScanCode: 	nil
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEventsFromQueue:
	Receiver: a HandMorph(454097152)
	Arguments and temporary variables: 
		anEventQueue: 	an InputEventSensor
		evt: 	[(886@193) dropFilesEvent nil]
		evtBuf: 	#(3 24460 4 886 193 0 1 1)
		type: 	3
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(203@506) corner: (219@522)
		owner: 	a WorldMorph(479349760) [world]
		submorphs: 	#()
		fullBounds: 	(203@506) corner: (219@522)
		color: 	Color blue
		extension: 	nil
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(783971328)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(203@506) mouseOver 15219093 nil]
		targetOffset: 	(477@198)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15219093 188 545 0 0 0 1)
		lastKeyScanCode: 	nil
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(454097152)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(203@506) corner: (219@522)
		owner: 	a WorldMorph(479349760) [world]
		submorphs: 	#()
		fullBounds: 	(203@506) corner: (219@522)
		color: 	Color blue
		extension: 	nil
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(783971328)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(203@506) mouseOver 15219093 nil]
		targetOffset: 	(477@198)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15219093 188 545 0 0 0 1)
		lastKeyScanCode: 	nil
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(479349760) [world]
		h: 	a HandMorph(454097152)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(454097152))
		viewBox: 	(0@0) corner: (976@665)
		canvas: 	a FormCanvas on: DisplayScreen(976x665x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	17034
		lastStepMessage: 	nil
		lastCycleTime: 	24473
		alarms: 	a Heap()
		lastAlarmTime: 	24448
		menuBuilder: 	nil
		activeHand: 	a HandMorph(454097152)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(454097152))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(454097152))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(454097152))
		viewBox: 	(0@0) corner: (976@665)
		canvas: 	a FormCanvas on: DisplayScreen(976x665x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	17034
		lastStepMessage: 	nil
		lastCycleTime: 	24473
		alarms: 	a Heap()
		lastAlarmTime: 	24448
		menuBuilder: 	nil
		activeHand: 	a HandMorph(454097152)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(479349760) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(454097152))
		viewBox: 	(0@0) corner: (976@665)
		canvas: 	a FormCanvas on: DispTHERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
29 January 2020 3:42:46.916906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(211988224))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(211988224))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 37 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 29 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(211988224))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContTHERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:42:47.006906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(211988224))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds -THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
29 January 2020 3:43:46.558906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(955805440))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(955805440))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 32 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 27 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(955805440))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


THERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:43:46.657906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(955805440))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
29 January 2020 3:44:54.694906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(156600576))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(156600576))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so .THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
29 January 2020 3:52:27.125906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1042046720))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1042046720))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 21 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 15 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1042046720))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so deTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 3:52:59.100906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(517725952))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(517725952))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 44 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 40 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(517725952))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:put:
MyTeamMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completionTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 3:54:08.450906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(413563136))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(413563136))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 11 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 7 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(413563136))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProTHERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:54:08.574906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(413563136))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStoppTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 3:56:02.483906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	3000
	Receiver's instance variables: 
#()

BestNeighborMind(RobotMind)>>setupOn:
	Receiver: a BestNeighborMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(907370240))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(907370240))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 54 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 50 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(907370240))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous THERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:56:02.652906 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(907370240))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't wTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 3:56:47.236887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	3000
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


THERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:56:47.285887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 3:56:52.751887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	3000
	Receiver's instance variables: 
#()

BestNeighborMind(RobotMind)>>setupOn:
	Receiver: a BestNeighborMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	15
		x: 	11
		energyValue: 	3000
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 61 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 47 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an AnnouncerTHERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 3:56:52.856887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(387324672))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #direction
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 4:01:48.396887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	73
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(13@30)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	7
		x: 	29
		energyValue: 	73
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(686132992))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(686132992))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 52 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 47 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(686132992))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(13@30)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(13@30)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:put:
MyTeamMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		selfTHERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 4:01:48.504887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(686132992))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(13@30)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(13@30)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #direction
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on diTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 4:02:11.235887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	75
	Receiver's instance variables: 
#()

BestNeighborMind(RobotMind)>>setupOn:
	Receiver: a BestNeighborMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	14
		x: 	10
		energyValue: 	75
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		didCheckForYellowSquare: 	nil
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1071521536))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1071521536))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 59 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 54 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1071521536))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
	THERE_BE_DRAGONS_HERE
#direction was sent to nil
29 January 2020 4:02:11.339887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #direction
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	direction
		exception: 	MessageNotUnderstood: receiver of "direction" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(1071521536))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(39@33)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(39@33)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 6'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 6'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(39@33)}
		robots: 	an OrderedCollection('Robot-TeamName'(39@33)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #direction
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, theTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
29 January 2020 4:07:29.480887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:put:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
		value: 	75
	Receiver's instance variables: 
#()

MyTeamMind(RobotMind)>>setupOn:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(39@33)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	14
		x: 	10
		energyValue: 	75
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		highestPointSquares: 	#()


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(555345664))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(555345664))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 51 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 47 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(39@33)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(39@33)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(555345664))
		announcer: 	nil
		map: 	Phase1Samples'Map 6'(0.0s1)
		location: 	(39@33)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't wanTHERE_BE_DRAGONS_HERE
Error: Instances of OrderedCollection class are not indexable
29 January 2020 4:15:11.095887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

OrderedCollection class(Object)>>error:
	Receiver: OrderedCollection
	Arguments and temporary variables: 
		aString: 	'Instances of OrderedCollection class are not indexable'
	Receiver's instance variables: 
		superclass: 	SequenceableCollection
		methodDict: 	a MethodDictionary(#add:->OrderedCollection>>#add: #add:after:->Ord...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection...etc...
		name: 	#OrderedCollection
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable-Ordered'


OrderedCollection class(Object)>>errorNotIndexable
	Receiver: OrderedCollection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	SequenceableCollection
		methodDict: 	a MethodDictionary(#add:->OrderedCollection>>#add: #add:after:->Ord...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection...etc...
		name: 	#OrderedCollection
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable-Ordered'


OrderedCollection class(Object)>>at:put:
	Receiver: OrderedCollection
	Arguments and temporary variables: 
		index: 	1
		value: 	93
	Receiver's instance variables: 
		superclass: 	SequenceableCollection
		methodDict: 	a MethodDictionary(#add:->OrderedCollection>>#add: #add:after:->Ord...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection...etc...
		name: 	#OrderedCollection
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable-Ordered'


BestNeighborMind(RobotMind)>>setupOn:
	Receiver: a BestNeighborMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(13@30)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	8
		x: 	28
		energyValue: 	93
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		highestPointSquares: 	OrderedCollection


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(718558464))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(718558464))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 41 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 34 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(718558464))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(13@30)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(13@30)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
OrderedCollection class(Object)>>error:
OrderedCollection class(Object)>>errorNotIndexable
OrderedCollection class(Object)>>at:put:
BestNeighborMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce:THERE_BE_DRAGONS_HERE
Instance of OrderedCollection class did not understand #add:
29 January 2020 4:16:21.576887 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

OrderedCollection class(Object)>>doesNotUnderstand: #add:
	Receiver: OrderedCollection
	Arguments and temporary variables: 
		aMessage: 	add: 93
		exception: 	MessageNotUnderstood: OrderedCollection class>>add:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	SequenceableCollection
		methodDict: 	a MethodDictionary(#add:->OrderedCollection>>#add: #add:after:->Ord...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection...etc...
		name: 	#OrderedCollection
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable-Ordered'


BestNeighborMind(RobotMind)>>setupOn:
	Receiver: a BestNeighborMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(13@30)-
		width: 	50
		height: 	50
		itterator: 	1
		y: 	8
		x: 	28
		energyValue: 	93
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	false
		highestPointSquares: 	OrderedCollection


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(31143424))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(31143424))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 53 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 48 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(13@30)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(31143424))
		announcer: 	nil
		map: 	Phase1Samples'Bap 5'(0.0s1)
		location: 	(13@30)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	BestNeighborMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(13@30)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(13@30)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(13@30)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Bap 5'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Bap 5'
		extent: 	(50@50)
		cells: 	a Dictionary(size 2500)
		startLocations: 	{(13@30)}
		robots: 	an OrderedCollection('Robot-TeamName'(13@30)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
OrderedCollection class(Object)>>doesNotUnderstand: #add:
BestNeighborMind(RobotMind)>>setupOn:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to rTHERE_BE_DRAGONS_HERE
Halt
31 January 2020 11:41:29.02819 am

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Robot(Object)>>halt
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


Robot>>navigator
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


Robot>>moveLeft
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 2 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary THERE_BE_DRAGONS_HERE
Halt
31 January 2020 11:41:48.85719 am

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Robot(Object)>>halt
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


Robot>>navigator
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


Robot>>moveLeft
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 58 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 49 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)-)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
Robot(Object)>>halt
Robot>>navigator
Robot>>moveLeft
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
BlockClosure>>repeat
THERE_BE_DRAGONS_HERE
Halt
31 January 2020 11:41:49.25319 am

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Robot(Object)>>halt
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


Robot>>navigator
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


Robot>>moveLeft
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 21 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 16 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.2s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)-)
		time: 	0.2s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: selTHERE_BE_DRAGONS_HERE
Halt
31 January 2020 11:41:49.37419 am

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Robot(Object)>>halt
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


Robot>>navigator
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


Robot>>moveLeft
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	nil
		energy: 	0
		isDead: 	false
		mindClass: 	nil
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	true
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	nil
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 33 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 27 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)-
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(952158976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotDirectionError
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.3s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)-)
		time: 	0.3s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)-)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)-)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.3s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)-)
		time: 	0.3s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
31 January 2020 12:10:15.18519 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>at:put:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anInteger: 	0
		anObject: 	#(#x #y)
		index: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


Dictionary>>at:at:put:
	Receiver: a Dictionary(0->an OrderedCollection() )
	Arguments and temporary variables: 
		firstKey: 	0
		secondKey: 	0
		aValue: 	#(#x #y)
		subDictionary: 	an OrderedCollection()
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(0->an OrderedCollection() nil nil nil nil)


MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(0->an OrderedCollection() )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(190024704))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(190024704))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 11 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 6 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(190024704))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real TTHERE_BE_DRAGONS_HERE
Instance of Dictionary did not understand #at:add:
31 January 2020 12:12:03.73419 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Dictionary(Object)>>doesNotUnderstand: #at:add:
	Receiver: a Dictionary(0->an OrderedCollection() )
	Arguments and temporary variables: 
		aMessage: 	at: 0 add: #(#x #y)
		exception: 	MessageNotUnderstood: Dictionary>>at:add:
		resumeValue: 	nil
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(0->an OrderedCollection() nil nil nil nil)


MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(0->an OrderedCollection() )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 29 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 25 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess teTHERE_BE_DRAGONS_HERE
Instance of Dictionary did not understand #at:add:
31 January 2020 12:12:03.87419 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Dictionary(Object)>>doesNotUnderstand: #at:add:
	Receiver: a Dictionary(0->an OrderedCollection() )
	Arguments and temporary variables: 
		aMessage: 	at: 0 add: #(#x #y)
		exception: 	MessageNotUnderstood: Dictionary>>at:add:
		resumeValue: 	nil
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(0->an OrderedCollection() nil nil nil nil)


MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(0->an OrderedCollection() )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 47 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 43 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(3@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(3@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(3@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
Dictionary(Object)>>doesNotUnderstand: #at:add:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
	THERE_BE_DRAGONS_HERE
Instance of Dictionary did not understand #at:add:
31 January 2020 12:12:04.04619 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Dictionary(Object)>>doesNotUnderstand: #at:add:
	Receiver: a Dictionary(0->an OrderedCollection() )
	Arguments and temporary variables: 
		aMessage: 	at: 0 add: #(#x #y)
		exception: 	MessageNotUnderstood: Dictionary>>at:add:
		resumeValue: 	nil
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(0->an OrderedCollection() nil nil nil nil)


MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(4@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(0->an OrderedCollection() )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(4@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(4@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(4@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(4@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	105
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(4@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(4@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(4@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	105
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 47 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 43 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(4@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(4@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(4@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	105
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.2s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(4@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(4@3)E)
		time: 	0.2s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(4@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(4@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.2s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(4@3)E)
		time: 	0.2s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.2s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(4@3)E)
		time: 	0.2s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	true


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
Dictionary(Object)>>doesNotUnderstand: #at:add:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
BlockClosure>>repeat
THERE_BE_DRAGONS_HERE
Instance of Dictionary did not understand #at:add:
31 January 2020 12:12:04.26919 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Dictionary(Object)>>doesNotUnderstand: #at:add:
	Receiver: a Dictionary(0->an OrderedCollection() )
	Arguments and temporary variables: 
		aMessage: 	at: 0 add: #(#x #y)
		exception: 	MessageNotUnderstood: Dictionary>>at:add:
		resumeValue: 	nil
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(0->an OrderedCollection() nil nil nil nil)


MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(5@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(0->an OrderedCollection() )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(5@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(5@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(5@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(5@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	151
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(5@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(5@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(5@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	151
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 12 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 8 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(5@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(5@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(762337536))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(5@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	151
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, sTHERE_BE_DRAGONS_HERE
Instance of True did not understand #whileTrue:
31 January 2020 12:43:10.57819 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

True(Object)>>doesNotUnderstand: #whileTrue:
	Receiver: true
	Arguments and temporary variables: 
		aMessage: 	whileTrue: [ | newPaths |
newPaths := Dictionary new.
1 to: paths val...etc...
		exception: 	MessageNotUnderstood: True>>whileTrue:
		resumeValue: 	nil
	Receiver's instance variables: 
true

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(1->an OrderedCollection(#(#x #y)) 2->an OrderedCollection(#...etc...
		firstPath: 	an OrderedCollection(#(#x #y))
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(271723776))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(271723776))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 37 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 32 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(271723776))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
True(Object)>>doesNotUnderstand: #whileTrue:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugReaTHERE_BE_DRAGONS_HERE
Instance of True did not understand #whileTrue:
31 January 2020 12:43:29.95819 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

True(Object)>>doesNotUnderstand: #whileTrue:
	Receiver: true
	Arguments and temporary variables: 
		aMessage: 	whileTrue: [ | newPaths |
newPaths := Dictionary new.
1 to: paths val...etc...
		exception: 	MessageNotUnderstood: True>>whileTrue:
		resumeValue: 	nil
	Receiver's instance variables: 
true

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(1->an OrderedCollection(#(#x #y)) 2->an OrderedCollection(#...etc...
		firstPath: 	an OrderedCollection(#(#x #y))
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(271723776))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(271723776))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 49 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 45 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(271723776))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(3@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(3@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(3@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
True(Object)>>doesNotUnderstand: #whileTrue:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldStateTHERE_BE_DRAGONS_HERE
Instance of True did not understand #whileTrue:
31 January 2020 12:44:09.19419 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

True(Object)>>doesNotUnderstand: #whileTrue:
	Receiver: true
	Arguments and temporary variables: 
		aMessage: 	whileTrue: [ | newPaths |
newPaths := Dictionary new.
Transcript crSh...etc...
		exception: 	MessageNotUnderstood: True>>whileTrue:
		resumeValue: 	nil
	Receiver's instance variables: 
true

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(1->an OrderedCollection(#(#x #y)) 2->an OrderedCollection(#...etc...
		firstPath: 	an OrderedCollection(#(#x #y))
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(55775744))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(55775744))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 33 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 28 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(55775744))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'MTHERE_BE_DRAGONS_HERE
Instance of Array did not understand #length
31 January 2020 12:45:18.20219 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>doesNotUnderstand: #length
	Receiver: an Array(an OrderedCollection(#(#x #y)) an OrderedCollection(#(#x #y)) an OrderedCollectio...etc...
	Arguments and temporary variables: 
		aMessage: 	length
		exception: 	MessageNotUnderstood: Array>>length
		resumeValue: 	nil
	Receiver's instance variables: 
an Array(an OrderedCollection(#(#x #y)) an OrderedCollection(#(#x #y)) an OrderedCollectio...etc...

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(1->an OrderedCollection(#(#x #y)) 2->an OrderedCollection(#...etc...
		firstPath: 	an OrderedCollection(#(#x #y))
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
		newPaths: 	a Dictionary()
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(376109568))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(376109568))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 33 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 30 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(376109568))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to raceTHERE_BE_DRAGONS_HERE
Instance of Array did not understand #length
31 January 2020 12:47:05.14219 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>doesNotUnderstand: #length
	Receiver: an Array(an OrderedCollection(#(#x #y)) an OrderedCollection(#(#x #y)) an OrderedCollectio...etc...
	Arguments and temporary variables: 
		aMessage: 	length
		exception: 	MessageNotUnderstood: Array>>length
		resumeValue: 	nil
	Receiver's instance variables: 
an Array(an OrderedCollection(#(#x #y)) an OrderedCollection(#(#x #y)) an OrderedCollectio...etc...

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(1->an OrderedCollection(#(#x #y)) 2->an OrderedCollection(#...etc...
		firstPath: 	an OrderedCollection(#(#x #y))
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
		newPaths: 	a Dictionary()
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(376109568))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(376109568))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 41 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 36 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(376109568))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
Array(Object)>>doesNotUnderstand: #length
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinTHERE_BE_DRAGONS_HERE
Instance of Array did not understand #length
31 January 2020 12:47:06.54119 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Array(Object)>>doesNotUnderstand: #length
	Receiver: an Array(an OrderedCollection(#(#x #y)) an OrderedCollection(#(#x #y)) an OrderedCollectio...etc...
	Arguments and temporary variables: 
		aMessage: 	length
		exception: 	MessageNotUnderstood: Array>>length
		resumeValue: 	nil
	Receiver's instance variables: 
an Array(an OrderedCollection(#(#x #y)) an OrderedCollection(#(#x #y)) an OrderedCollectio...etc...

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(1->an OrderedCollection(#(#x #y)) 2->an OrderedCollection(#...etc...
		firstPath: 	an OrderedCollection(#(#x #y))
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
		newPaths: 	a Dictionary()
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(376109568))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(376109568))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 49 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 45 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(376109568))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(3@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(3@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(3@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
Array(Object)>>doesNotUnderstand: #length
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot detTHERE_BE_DRAGONS_HERE
Error: Instances of False are not indexable
31 January 2020 1:11:16.71419 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

False(Object)>>error:
	Receiver: false
	Arguments and temporary variables: 
		aString: 	'Instances of False are not indexable'
	Receiver's instance variables: 
false

False(Object)>>errorNotIndexable
	Receiver: false
	Arguments and temporary variables: 

	Receiver's instance variables: 
false

False(Object)>>at:
	Receiver: false
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
false

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(1->an OrderedCollection(#(#x #y)) 2->an OrderedCollection(#...etc...
		firstPath: 	an OrderedCollection(#(#x #y))
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
		newPaths: 	a Dictionary()
		key: 	1
		path: 	an OrderedCollection(#(#x #y))
		neighbors: 	an Array((3@3)=88 (2@4)=45 (1@3)=37 (2@2)=62)
		neighborIndex: 	1
		neighbor: 	nil
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(445034752))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(445034752))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
THERE_BE_DRAGONS_HERE
Error: Instances of False are not indexable
31 January 2020 1:13:00.42119 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

False(Object)>>error:
	Receiver: false
	Arguments and temporary variables: 
		aString: 	'Instances of False are not indexable'
	Receiver's instance variables: 
false

False(Object)>>errorNotIndexable
	Receiver: false
	Arguments and temporary variables: 

	Receiver's instance variables: 
false

False(Object)>>at:
	Receiver: false
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
false

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	a Dictionary(1->an OrderedCollection(#(#x #y)) 2->an OrderedCollection(#...etc...
		firstPath: 	an OrderedCollection(#(#x #y))
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
		newPaths: 	a Dictionary()
		key: 	1
		path: 	an OrderedCollection(#(#x #y))
		neighbors: 	an Array((3@3)=88 (2@4)=45 (1@3)=37 (2@2)=62)
		neighborIndex: 	1
		neighbor: 	nil
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(993110272))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(993110272))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 30 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 26 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(993110272))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in PhasTHERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:24:27.69419 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 0
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
0

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(602763008))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(602763008))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 41 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 36 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(602763008))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyTHERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:25:05.56619 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 0
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
0

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	0
		y: 	0
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(769470720))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(769470720))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 44 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 39 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(769470720))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiveTHERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:29:50.80219 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 2
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
2

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	2
		y: 	3
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(884831232))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(884831232))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 42 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 38 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(884831232))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determiTHERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:30:53.96019 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 2
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
2

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	2
		y: 	3
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(946834432))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(946834432))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 31 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 27 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(946834432))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nTHERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:32:04.47919 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 2
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
2

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	2
		y: 	3
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(346682368))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(346682368))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 43 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 38 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(346682368))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:33:00.31719 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 2
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
2

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	2
		y: 	3
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(594702080))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(594702080))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 39 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 35 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(594702080))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStoTHERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:34:21.67419 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 3
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
3

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@2)-
		currentItterations: 	1
		x: 	3
		y: 	2
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@2)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(3@2)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(3@2)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(572647680))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(3@2)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	135
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotNorth
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@2)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@2)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(572647680))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(3@2)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	135
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotNorth
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 48 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 44 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@2)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@2)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(572647680))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.2s1)
		location: 	(3@2)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	135
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotNorth
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.2s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(3@2)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@2)E)
		time: 	0.2s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(3@2)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(3@2)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.2s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@2)E)
		time: 	0.2s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.2s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@2)E)
		time: 	0.2s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take toTHERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:34:23.07519 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 4
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
4

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(4@2)-
		currentItterations: 	1
		x: 	4
		y: 	2
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(4@2)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(4@2)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(4@2)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(572647680))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(4@2)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	209
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(4@2)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(4@2)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(572647680))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(4@2)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	209
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 56 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 52 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(4@2)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(4@2)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(572647680))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.3s1)
		location: 	(4@2)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	209
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.3s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(4@2)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(4@2)E)
		time: 	0.3s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(4@2)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(4@2)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.3s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(4@2)E)
		time: 	0.3s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.3s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(4@2)E)
		time: 	0.3s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
BlockClosure>>repeat
[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:34:31.78919 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 2
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
2

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	2
		y: 	3
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(276858112))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(276858112))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 46 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 42 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(276858112))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:35:51.26319 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 2
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
2

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	2
		y: 	3
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(276858112))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(276858112))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 41 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 38 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(276858112))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTruTHERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:36:04.78419 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 3
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
3

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
		currentItterations: 	1
		x: 	3
		y: 	3
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(276858112))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(276858112))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 44 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 40 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(276858112))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(3@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(3@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(3@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeTHERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:36:33.35619 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 2
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
2

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	2
		y: 	3
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(895294976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(895294976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 43 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 39 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(895294976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #y
31 January 2020 1:36:38.10419 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #y
	Receiver: 3
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: SmallInteger>>y
		resumeValue: 	nil
	Receiver's instance variables: 
3

MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
		currentItterations: 	1
		x: 	3
		y: 	3
		paths: 	nil
		firstPath: 	an OrderedCollection()
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(895294976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(895294976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 47 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 43 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(895294976))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(3@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(3@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(3@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #y
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
OrderedCollection>>do:
[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in THERE_BE_DRAGONS_HERE
KeyNotFound: key 1 not found in Dictionary
31 January 2020 2:05:42.91119 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Dictionary>>errorKeyNotFound:
	Receiver: a Dictionary(0->0 )
	Arguments and temporary variables: 
		aKey: 	1
	Receiver's instance variables: 
		tally: 	1
		array: 	{0->0. nil. nil. nil. nil}


[ self errorKeyNotFound: key ] in Dictionary>>at:
	Receiver: a Dictionary(0->0 )
	Arguments and temporary variables: 
		key: 	1
	Receiver's instance variables: 
		tally: 	1
		array: 	{0->0. nil. nil. nil. nil}


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary(0->0 )
	Arguments and temporary variables: 
		key: 	1
		aBlock: 	[ self errorKeyNotFound: key ]
	Receiver's instance variables: 
		tally: 	1
		array: 	{0->0. nil. nil. nil. nil}


Dictionary>>at:
	Receiver: a Dictionary(0->0 )
	Arguments and temporary variables: 
		key: 	1
	Receiver's instance variables: 
		tally: 	1
		array: 	{0->0. nil. nil. nil. nil}


MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	2
		y: 	3
		paths: 	a Dictionary(1->an OrderedCollection(#(2 3)) 2->an OrderedCollection(#(2...etc...
		firstPath: 	an OrderedCollection(#(2 3))
		pathID: 	1
		pathEnergies: 	a Dictionary(0->0 )
		newPaths: 	a Dictionary()
		key: 	1
		path: 	an OrderedCollection(#(2 3))
		neighbors: 	an Array((3@3)=88 (2@4)=45 (1@3)=37 (2@2)=62)
		neighborIndex: 	1
		neighbor: 	(3@3)=88
		newVal: 	nil
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(253212928))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(253212928))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 3 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
THERE_BE_DRAGONS_HERE
KeyNotFound: key 2 not found in Dictionary
31 January 2020 2:06:15.02319 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Dictionary>>errorKeyNotFound:
	Receiver: a Dictionary(1->0 )
	Arguments and temporary variables: 
		aKey: 	2
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. 1->0. nil. nil. nil}


[ self errorKeyNotFound: key ] in Dictionary>>at:
	Receiver: a Dictionary(1->0 )
	Arguments and temporary variables: 
		key: 	2
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. 1->0. nil. nil. nil}


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary(1->0 )
	Arguments and temporary variables: 
		key: 	2
		aBlock: 	[ self errorKeyNotFound: key ]
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. 1->0. nil. nil. nil}


Dictionary>>at:
	Receiver: a Dictionary(1->0 )
	Arguments and temporary variables: 
		key: 	2
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. 1->0. nil. nil. nil}


MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
		currentItterations: 	1
		x: 	2
		y: 	3
		paths: 	a Dictionary(1->an OrderedCollection(#(2 3)) 2->an OrderedCollection(#(2...etc...
		firstPath: 	an OrderedCollection(#(2 3))
		pathID: 	1
		pathEnergies: 	a Dictionary(1->0 )
		newPaths: 	a Dictionary()
		key: 	2
		path: 	an OrderedCollection(#(2 3))
		neighbors: 	an Array((3@3)=88 (2@4)=45 (1@3)=37 (2@2)=62)
		neighborIndex: 	1
		neighbor: 	(3@3)=88
		newVal: 	62
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(833973760))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(833973760))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 37 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 32 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(2@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(2@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(833973760))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.0s1)
		location: 	(2@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	0
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	nil
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(2@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(2@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(2@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.0s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(2@3)E)
		time: 	0.0s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
Dictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at:
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>THERE_BE_DRAGONS_HERE
KeyNotFound: key 2 not found in Dictionary
31 January 2020 2:06:27.29119 pm

VM: Win32 - X64 - 6.2 - CoInterpreter VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2509 uuid: 91e81f64-95de-4914-a960-8f842be3a194 Sep 13 2019
VM: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm Date: Wed Jul 3 16:41:39 2019 CommitHash: 4e4c5b5a0 Plugins: 201907031441-pharo Guille@DESKTOP-MG6660L:projects/vm7/opensmalltalk-vm

Image: Pharo7.0.4 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)]

Dictionary>>errorKeyNotFound:
	Receiver: a Dictionary(1->0 )
	Arguments and temporary variables: 
		aKey: 	2
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. 1->0. nil. nil. nil}


[ self errorKeyNotFound: key ] in Dictionary>>at:
	Receiver: a Dictionary(1->0 )
	Arguments and temporary variables: 
		key: 	2
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. 1->0. nil. nil. nil}


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary(1->0 )
	Arguments and temporary variables: 
		key: 	2
		aBlock: 	[ self errorKeyNotFound: key ]
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. 1->0. nil. nil. nil}


Dictionary>>at:
	Receiver: a Dictionary(1->0 )
	Arguments and temporary variables: 
		key: 	2
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. 1->0. nil. nil. nil}


MyTeamMind(RobotMind)>>plotPathForNN:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
		currentItterations: 	1
		x: 	3
		y: 	3
		paths: 	a Dictionary(1->an OrderedCollection(#(3 3)) 2->an OrderedCollection(#(3...etc...
		firstPath: 	an OrderedCollection(#(3 3))
		pathID: 	1
		pathEnergies: 	a Dictionary(1->0 )
		newPaths: 	a Dictionary()
		key: 	2
		path: 	an OrderedCollection(#(3 3))
		neighbors: 	an Array((4@3)=17 (3@4)=19 (2@3) (3@2)=47)
		neighborIndex: 	1
		neighbor: 	(4@3)=17
		newVal: 	47
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


MyTeamMind(RobotMind)>>determineDirectionForRobot:
	Receiver: a MyTeamMind
	Arguments and temporary variables: 
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		direction: 	a RobotEast
		doesYellowSquareExist: 	true
		highestPointSquares: 	an OrderedCollection(95 96 93 92 91 94 95 91 97 94 91 96 9...etc...
		depthNN: 	7
		currentX: 	0
		currentY: 	0


Robot>>mindDoOneCycle:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		sensorData: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(833973760))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(833973760))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


BlockClosure>>ensure:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aBlock: 	[ "evaluate the receiver"
theProcess := nil.	"it has completed, so ..."...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 40 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
		theProcess: 	a Process in nil
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


BlockClosure>>on:do:
	Receiver: [ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		thePr...etc...
	Arguments and temporary variables: 
		exception: 	TimedOut
		handlerAction: 	[ :e | 
e tag == tag
	ifTrue: [ timeoutBlock value ]
	ifFalse: [...etc...
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>valueWithin:onTimeout:
		startpc: 	266
		numArgs: 	0


BlockClosure>>valueWithin:onTimeout:
	Receiver: [ self mindDoOneCycle: sketchRobot ]
	Arguments and temporary variables: 
		theProcess: 	a Process in nil
		aDuration: 	0:00:00:00.1
		timeoutBlock: 	[ timedOut := true ]
		delay: 	a Delay(100 msecs; 36 msecs remaining)
		watchdog: 	a Process in [ delaySemaphore wait ] in Delay>>wait
		tag: 	[ self mindDoOneCycle: sketchRobot ]
	Receiver's instance variables: 
		outerContext: 	Robot>>determineDirectionWithin:
		startpc: 	122
		numArgs: 	0


Robot>>determineDirectionWithin:
	Receiver: 'Robot-TeamName'(3@3)E
	Arguments and temporary variables: 
		aDuration: 	0:00:00:00.1
		sketchRobot: 	'Robot-TeamName'(3@3)-
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(833973760))
		announcer: 	nil
		map: 	Phase1Samples'Map 1'(0.1s1)
		location: 	(3@3)
		name: 	'Robot-TeamName'
		mind: 	a MyTeamMind
		energy: 	88
		isDead: 	false
		mindClass: 	MyTeamMind
		mindProcess: 	nil
		stepSemaphore: 	a Semaphore()
		mindProcessStep: 	a Semaphore()
		timedOut: 	false
		direction: 	a RobotEast
		debug: 	false
		ghost: 	false
		id: 	$A


[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
		robot: 	'Robot-TeamName'(3@3)E
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


OrderedCollection>>do:
	Receiver: an OrderedCollection('Robot-TeamName'(3@3)E)
	Arguments and temporary variables: 
		aBlock: 	[ :robot | robot determineDirectionWithin: stepTime seconds ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array('Robot-TeamName'(3@3)E)
		firstIndex: 	1
		lastIndex: 	1


[ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


BlockClosure>>repeat
	Receiver: [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case...etc...
		startpc: 	252
		numArgs: 	0


[ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] repeat ] in Phase1Samples(RobotMap)>>runProcessLoop
	Receiver: Phase1Samples'Map 1'(0.1s1)
	Arguments and temporary variables: 
		debugRealTimeStarted: 	nil
		debugRealTimeStopped: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		name: 	'Map 1'
		extent: 	(20@20)
		cells: 	a Dictionary(size 400)
		startLocations: 	{(2@3)}
		robots: 	an OrderedCollection('Robot-TeamName'(3@3)E)
		time: 	0.1s1
		stepTime: 	0.1s1
		endTime: 	20.0s1
		finishFlag: 	false
		debugState: 	nil
		mapProcess: 	a Process in nil
		mapProcessStep: 	a Semaphore()
		runContinuous: 	false


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forwa...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	Phase1Samples(RobotMap)>>runProcessLoop
		startpc: 	247
		numArgs: 	0



--- The full stack ---
Dictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at:
Dictionary>>at:ifAbsent:
Dictionary>>at:
MyTeamMind(RobotMind)>>plotPathForNN:
MyTeamMind(RobotMind)>>determineDirectionForRobot:
Robot>>mindDoOneCycle:
[ self mindDoOneCycle: sketchRobot ] in Robot>>determineDirectionWithin:
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout:
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
Robot>>determineDirectionWithin:
[ :robot | robot determineDirectionWithin: stepTime seconds ] in [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show: debugRealTimeStopped asSeconds - debugRealTimeStarted asSeconds."
		mapProcess terminate ].
mapProcessStep wait.
self announce: (RobotMapStep copyMap: self).

"With multiple robots, the following may take too long to be in main UI loop,
				hence we are running in our  own process. This has no impact on display."
robots
	do: [ :robot | robot determineDirectionWithin: stepTime seconds ].

"The following executes quickly and impacts display, so defer to UI loop."
WorldState
	defer: [ robots do: [ :robot | robot move ].
		self updateMap.
		runContinuous
			ifTrue: [ mapProcessStep signal ] ] ] in [ [ self isFinished
	ifTrue:
		[ runContinuous := false.	"In case stepped back, then forward, don't want to race to completion "
		debugRealTimeStopped := Time now.
		"Transcript crShow: 'Real Time Stopped: '; show: debugRealTimeStopped.
					Transcript crShow: 'Real Time Elapsed: '; show