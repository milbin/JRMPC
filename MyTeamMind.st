'From Pharo7.0.4 of 13 August 2019 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)] on 18 February 2020 at 10:52:58.296323 pm'!RobotMind subclass: #MyTeamMind	instanceVariableNames: 'pathToHighestDensityPoint hasHighDensityAreas averageEnergy doesYellowSquareExist highestPointSquares depthNN depthDijkstra directionList statements warpCellEndpoints'	classVariableNames: ''	poolDictionaries: ''	category: 'JRMPC-Phase1-Minds'!!MyTeamMind methodsFor: 'testing' stamp: 'BenTran 2/16/2020 22:55'!isTrapped: point Robot: sketchRobot Integer: count Set: squares    "comment stating purpose of message"    | x y neighbors|    x := point x.    y := point y.    "get the first neighbors arround the current point passed in as a parameter"    neighbors := self getFourNeighbors: x @ y Robot: sketchRobot.    (count = 0)ifTrue: [ ^ squares ]        ifFalse: [             1 to: neighbors size do: [ :neighborIndex |                | neighbor |                neighbor := neighbors at: neighborIndex.                (neighbor isMemberOf: DeathCell)                    ifFalse: [                         squares add: neighbor location.                        squares addAll:(self isTrapped: neighbor location Robot: sketchRobot Integer: count - 1 Set: squares).                                                ]                     ].                 ^ squares                 ]! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/18/2020 22:52'!setupOn: sketchRobot	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 This method facilitates initial setup of the mind related to the map parameters.	 It is called once by the competition framework when the mind is instantiated. 	 'sketchRobot' is a copy of the world as seen by the robot's scanners 	"				self determineWarpEndpoints: sketchRobot.	self AstarPlus: 25@25 Point: (sketchRobot location) Robot: sketchRobot		! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/7/2020 20:33'!direction	"COMPETITION ENTRIES _MUST_NOT_ OVERRIDE THIS METHOD	 This method is how the game later reads the mind's decision	"		"self assert: (direction isKindOf: RobotDirection)."	^ direction! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/7/2020 20:34'!recoverOn: sketchRobot	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 If the mind doesn't complete its step within the designated time, its process is terminated.	 Depending on how you manage your data objects, they may end up corrupted.	 This method allows the mind to reset and continue playing. 	 'sketchRobot' is a copy of the world as seen by the robot's scanners 	"	Transcript crShow: 'PROGRAM TOOK TOO LONG, EXITING'.	self setupOn: sketchRobot! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/18/2020 10:21'!determineDirectionForRobot: sketchRobot     "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.     This method is the main entrypoint for competition entries.     It is called each time the game world progresses one step in time.     'sketchRobot' is a copy of the map/robots as seen by a robot's scanners (i.e. no internal state).      Each time step provides a new independent scan 'sketchRobot'.     The mind instance remains constant across steps (i.e. it has memory across time steps).       The actual map/robots remain inaccessible to prevent accidental corruption of the game.    "	| point |	(averageEnergy = -123456)ifTrue: [ "this will only get called once when the robot is setup since the average point value is not known"		| highestDensityPoint densityOfPoint|		highestDensityPoint := self determineHighestDensityPoint: sketchRobot.		densityOfPoint := self determineDensityArroundPoint: highestDensityPoint Robot: sketchRobot. 		(densityOfPoint > (averageEnergy *3))ifTrue: [ 			self getDirectPathToPoint: highestDensityPoint  Robot: sketchRobot.			]		].		"this block of code checks to see if there s another high density point on the board that we can navigate to once we finish getting all the cells in the imediate vicinity"	((pathToHighestDensityPoint isEmpty) and: (directionList size = 1))ifTrue: [ 			| density highestDensityPoint |			density := self determineDensityArroundPoint: (sketchRobot location) Robot: sketchRobot.			(density < (averageEnergy))ifTrue: [ 				| densityOfPoint |				highestDensityPoint := self determineHighestDensityPoint: sketchRobot.				densityOfPoint := self determineDensityArroundPoint: highestDensityPoint Robot: sketchRobot. 				((densityOfPoint > (averageEnergy * 3)) or: (density < 0))ifTrue: [ 					self getDirectPathToPoint: highestDensityPoint Robot: sketchRobot.				 ]			]		 ].					(directionList isEmpty)ifTrue: [ 			(pathToHighestDensityPoint isEmpty)ifFalse: [ 				point := pathToHighestDensityPoint first.				pathToHighestDensityPoint removeAt: 1.			]ifTrue:[				self Dijkstra: sketchRobot. 				point := directionList first.				directionList removeAt: 1.				]		 ]ifFalse:[			point := directionList first.			directionList removeAt: 1.		].					direction := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). 	! !!MyTeamMind methodsFor: 'initialization' stamp: 'BenTran 2/17/2020 21:54'!initialize 	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 This method is not part of the competition API, but a standard part of Pharo	 called when objects are instatiated."	doesYellowSquareExist := false.	highestPointSquares := OrderedCollection new. 	pathToHighestDensityPoint := OrderedCollection new.	hasHighDensityAreas := true.	averageEnergy := -123456.	depthNN := 3. "number of layers deep that the NN should look at"	depthDijkstra := 4.	directionList := OrderedCollection new.	warpCellEndpoints := Dictionary new.	super initialize! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/17/2020 20:34'!determineDensityArroundPoint: point Robot: sketchRobot    | neighborQueue neighbors totalEnergy x y currentCell|.    x := point x.    y := point y.    totalEnergy := 0.    neighborQueue := OrderedCollection new.	currentCell := sketchRobot map cellAt: x@y.		"check if our central cell is either a death call or a warp cell"	(currentCell isMemberOf: WarpCell)ifTrue: [ 		x := currentCell target x.		y := currentCell target y.		totalEnergy := (sketchRobot map cellAt: (currentCell target)) energy. 		 ]ifFalse:[			(currentCell isMemberOf: DeathCell )ifTrue: [ 				^0.				 ]ifFalse:[				totalEnergy := currentCell energy.				]		].    "get the first neighbors arround the current point passed in as a parameter"    neighbors := self getFourNeighbors: x@y Robot: sketchRobot.    1 to: (neighbors size) do: [ : neighborIndex|        | neighbor neighborLocation|        neighbor := (neighbors at: neighborIndex).		  neighborLocation := neighbor location.        (neighborQueue includes: neighborLocation)ifFalse: [             (neighbor isMemberOf: DeathCell)ifFalse:[                neighborQueue addLast: neighborLocation.                	].				(neighbor isMemberOf: WarpCell)ifTrue:[                neighborQueue addLast: (neighbor target).                	]                ]            ].    "get the second order neighbors arround those first points"    1 to: (neighborQueue size) do: [ : i|        neighbors := self getFourNeighbors: (neighborQueue at: i) Robot: sketchRobot.        1 to: (neighbors size) do: [ : neighborIndex|            | neighbor neighborLocation|        neighbor := (neighbors at: neighborIndex).		  neighborLocation := neighbor location.        (neighborQueue includes: neighborLocation)ifFalse: [             (neighbor isMemberOf: DeathCell)ifFalse:[                neighborQueue addLast: neighborLocation.                	].				(neighbor isMemberOf: WarpCell)ifTrue: [                neighborQueue addLast: (neighbor target).                	]                ]            ]    ].    "once we have a list of all the neighbors arround the given point, sum up the point values for those neighbors"    1 to: (neighborQueue size) do: [ : i|        | neighbor |        neighbor := neighborQueue at: i.            totalEnergy := totalEnergy + ((sketchRobot map cellAt: neighbor) energy)        ].    ^totalEnergy.	! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/16/2020 22:37'!determineWarpEndpoints: sketchRobot	| width height |. "initilize the variable"   width := sketchRobot map width.   height := sketchRobot map height.	   1 to: height do:[:y | "assigns itterator number to y"        1 to: width do:[:x |			| cell |			cell := (sketchRobot map cellAt: x@y).			(cell isMemberOf: WarpCell)ifTrue: [ 				| endpoint |				endpoint := cell target.				warpCellEndpoints at: (cell location) put: endpoint.				 ]		]	].! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/18/2020 22:43'!determineHighestDensityPoint: sketchRobot	| width height maxEnergy maxEnergyPoint totalEnergyOnGrid squares|. "initilize the variable"   width := sketchRobot map width.   height := sketchRobot map height.	totalEnergyOnGrid := 0 .	maxEnergy := -10000000000. 	maxEnergyPoint := 1@1.	   1 to: height by: 2 do:[:y | "assigns itterator number to y"        1 to: width by: 2 do:[:x |			| totalEnergy |			totalEnergy := self determineDensityArroundPoint: x@y Robot: sketchRobot.			totalEnergyOnGrid := totalEnergyOnGrid + totalEnergy.						squares:= Set new.							(totalEnergy > maxEnergy)ifTrue: [ 					((sketchRobot map cellAt: x@y) isMemberOf: DeathCell)ifFalse:[						squares := (self isTrapped: x@y Robot: sketchRobot Integer: 4 Set: squares).						warpCellEndpoints keysAndValuesDo: [ :key :value | 							(squares includes: value)ifTrue: [ 									squares addAll: (Interval from: 1 to: 2).							 	]							].						((squares size) > 38 )ifTrue: [							maxEnergy := totalEnergy.							maxEnergyPoint := x@y				 		]				]			]		]	].	averageEnergy := (totalEnergyOnGrid / ((width/2) * (height/2))) asInteger .	^maxEnergyPoint.! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/17/2020 23:02'!getFourNeighbors: point Robot: sketchRobot	| x y right down left up|	x := point x.	y := point y.	right := (sketchRobot map cellAt: (x+1)@y).	down := (sketchRobot map cellAt: x@(y-1)).	left := (sketchRobot map cellAt: (x-1)@y).	up := (sketchRobot map cellAt: x@(y+1)).		^(Array newFrom: {right . down . left . up})! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/14/2020 16:57'!getDirectPathToPoint: point Robot: sketchRobot	| currentX currentY targetX targetY|		currentX := sketchRobot location x.		currentY := sketchRobot location y.		targetX := point x.		targetY := point y.		" add x vals to the path"		(targetX < currentX)ifTrue: [ 				currentX to: targetX by: -1 do: [:x|					pathToHighestDensityPoint addLast: (Array newFrom: {x . currentY})		 		]			 ]ifFalse:[			currentX to: targetX do: [:x|				pathToHighestDensityPoint addLast: (Array newFrom: {x . currentY})		 	]		].	" add y vals to the path"	(targetY < currentY)ifTrue: [ 			currentY to: targetY by: -1 do: [:y|				pathToHighestDensityPoint addLast: (Array newFrom: {targetX . y})		 	]		 ] ifFalse: [ 			currentY to: targetY do: [:y|				pathToHighestDensityPoint addLast: (Array newFrom: {targetX . y})		 	]		]! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/18/2020 22:42'!Dijkstra: sketchRobot	"create a new list of all points within the robots scanning radius ----------------------------------------"	| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |	"Transcript crShow: 'Dijkstra HAS BEEN CALLED -----------------------------------------------------'."		scanningRadius := depthDijkstra.	grid := OrderedCollection new.	pointsList := OrderedCollection new.	x := sketchRobot location x.	y := sketchRobot location y.	1 to: scanningRadius * 2 + 1 do: [ :xCord | 		1 to: scanningRadius * 2 + 1 do: [ :yCord | 			| xPoint yPoint point |			xPoint := x - scanningRadius + xCord - 1.			yPoint := y - scanningRadius + yCord - 1.			"this will take a given coordinate and it wrap around the board"			point := self standardizePoint: xPoint Integer: yPoint	Integer: sketchRobot map width	Integer: sketchRobot map height.			(grid includes: point) ifFalse: [ "sometimes you get repeats because of the point standardization"					| pointValue pointObj|					grid addLast: point.					pointObj := (sketchRobot map cellAt: (point at: 1) @ (point at: 2)).					(pointObj isMemberOf: WarpCell)ifTrue: [ 							| maxNeighborEnergy warpCellNeighbors|							maxNeighborEnergy := 0.							warpCellNeighbors := self getFourNeighbors: (pointObj target) Robot: sketchRobot.							1 to: warpCellNeighbors size do: [ :index | 								(((warpCellNeighbors at: index) energy) > maxNeighborEnergy)ifTrue:[									maxNeighborEnergy := ((warpCellNeighbors at: index) energy)									]								].									pointValue := maxNeighborEnergy.					]ifFalse:[						pointValue := pointObj energy.					].				pointsList addLast: pointValue .			]		] 	].	"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"	"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"	highestPoint := pointsList max.	startingPoint := Array newFrom:{x . y}.	distanceFromStart := Dictionary new.	previousVertex := Dictionary new.	visited := OrderedCollection new.	unVisited := grid copy.	"Transcript crShow: 'STARTING POINT'.	Transcript show: startingPoint."		" set all distances to infinity and initlize previous distance dict with default keys"	1 to: grid size do: [ :i | 		| point |		point := grid at: i.		distanceFromStart at: point put: 1000000.	"1 million, number must be very large because distance from starting point to all other points is unkown at this point"		previousVertex at: point put: (Array newFrom: #(-1 -1)) ].	distanceFromStart at: startingPoint put: 0.			"point visit loop --------------------------------------------------------------------------------------------"	[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |			"find min value in distanceFromStart dict"			minValue := 10000000.	"10 million"			distanceFromStart	keysAndValuesDo: [ :key :value | 					((value < minValue) & ((visited includes: key) not))	ifTrue: [ 							currentPoint := key.							minValue := value 							]						 ].						"iterate through neighbors"			neighbors := self	getFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)	Robot: sketchRobot.			1 to: neighbors size do: [ :i | 				| neighbor neighborPoint |				neighbor := neighbors at: i.				neighborPoint := Array newFrom: {neighbor location x. neighbor location y}.				(grid includes: neighborPoint)ifTrue: [ | distance distanceFromNeighbor neighborEnergy|						(neighbor isMemberOf: DeathCell)ifTrue: [ 							neighborEnergy := -1000000.							 ]ifFalse:[								(neighbor isMemberOf: WarpCell)ifTrue: [ 									| maxNeighborEnergy warpCellNeighbors|									maxNeighborEnergy := 0.									warpCellNeighbors := self getFourNeighbors: (neighbor target) Robot: sketchRobot.									1 to: warpCellNeighbors size do: [ :index | 										(((warpCellNeighbors at: index) energy) > maxNeighborEnergy)ifTrue:[											maxNeighborEnergy := ((warpCellNeighbors at: index) energy)											]										].									neighborEnergy := maxNeighborEnergy.								]ifFalse:[									neighborEnergy := neighbor energy.								]							].						distance := (distanceFromStart at: currentPoint) + (highestPoint - neighborEnergy).						distanceFromNeighbor := distanceFromStart at: neighborPoint.						(distance < distanceFromNeighbor) ifTrue: [ 								distanceFromStart at: neighborPoint put: distance.								previousVertex at: neighborPoint put: currentPoint 								] 							] 						].			visited addLast: currentPoint.			unVisited remove: currentPoint 			].		"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"	shortestPathLength := 1000000.	"1 million"	bestPath := OrderedCollection new.	[ bestPath isEmpty ]		whileTrue: [ 1 to: grid size do: [ :i | 				| point |				point := grid at: i.				((distanceFromStart at: point) < shortestPathLength	& (point = startingPoint) not )ifTrue: [ "point is not equal to starting point"						| path newPoint shouldBreak |						path := OrderedCollection new.						"work backwards from best point to find optimal path"						path addLast: point.	"the point we are trying to is the first item since the list will be reversed"						newPoint := point.	"initialize newPoint w since this will be reassigned in the while loop"						shouldBreak := false.						[ shouldBreak ]whileFalse:[							 newPoint := previousVertex at: newPoint.	"get the previous point and add it to the list"								path addLast: newPoint.								newPoint = startingPoint									ifTrue: [ "if the starting point is equal to current point we found a path"										"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"										path size > scanningRadius											ifTrue: [ 												shortestPathLength := distanceFromStart at: point.												bestPath := path	"this best path is only truly the best once the while loop has exited" 													].										shouldBreak := true 										].								path size > (scanningRadius * 4)									ifTrue: [ shouldBreak := true 										] 									] 								] 							].			"Transcript crShow: 'could not find path'."			scanningRadius := scanningRadius - 1 			].	bestPath removeLast.	bestPath := bestPath reversed.	directionList := bestPath! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:33'!plotPathForNN: sketchRobot	"variable initilization"	| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|	currentItterations := 1.	x := sketchRobot location x.	y := sketchRobot location y.	pathID := 1.	pathEnergies := Dictionary newFrom: {1 -> 0.}.		"paths = {0:[(x, y)]} in python"	firstPath := OrderedCollection new.	firstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"	paths := Dictionary newFrom: {1 -> firstPath.}. 		[currentItterations <= depthNN] whileTrue: [ 		|newPaths|.		newPaths := Dictionary new.		((paths keys sorted) first) to: ((paths keys sorted) last) do: [ 			:key|			|path neighbors|.				path := paths at: key.			"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."			neighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"			1 to: 4 do: [ 				: neighborIndex|				|neighbor neighborPoint|.				neighbor := (neighbors at: neighborIndex). 				neighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.				"Transcript crShow: path.				Transcript crShow: neighborPoint.	"					(path includes: neighborPoint )ifFalse: [					 |newVal newPath|.					newVal := (pathEnergies at: key) + (neighbor energy).					newPath := path copy.					newPath addLast: neighborPoint.					newPaths at: pathID put: newPath.					pathEnergies at: pathID put: newVal.					pathID := (pathID + 1) 															]				ifTrue:[					"Transcript crShow: path.					Transcript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).					Transcript crShow: 'DOES  INCLUDE'."					].				 ]. 			 ].		paths := newPaths copy.		currentItterations := currentItterations + 1.		 ].	bestPathID  := 0.	1 to: ((pathEnergies values) size) do: [ 			:key|			((pathEnergies values max) = (pathEnergies at: key))ifTrue:[				bestPathID := key				].			].	bestPath := paths at: bestPathID.	bestPath removeAt: 1.	directionList := bestPath. "stores best path as a instance variable"				! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:32'!DetermineRobotMovementFromPoint: point Robot: sketchRobot	| fourNeighbors directionDict|	fourNeighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"	directionDict := Dictionary newFrom: {1 -> RobotEast soleInstance . 2 -> RobotSouth soleInstance . 3 -> RobotWest soleInstance . 4 -> RobotNorth soleInstance .}.	1 to: 4 do: [ 				: neighborIndex|				|neighbor neighborPoint|.				neighbor := (fourNeighbors at: neighborIndex). 				neighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.				(neighborPoint = point)ifTrue: [ 					^(directionDict at: neighborIndex)				].	].	! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:34'!standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows	"this will take a given coordinate and it wrap around the board"	| newXPoint newYPoint |.		newXPoint := ((xPoint \\ columns) abs). "\\ is the same as % in python, coordinate system starts at 1,1 so we need to shift everything by 1"	newYPoint := ((yPoint \\ rows) abs).		(xPoint = 0)ifTrue: [ 		newXPoint := columns 		 ].	(newXPoint = 0)ifTrue: [ 		newXPoint := columns 		 ].	(yPoint = 0)ifTrue: [ 		newYPoint := rows 		 ].	(newYPoint = 0)ifTrue: [ 		newYPoint := rows 		 ].		^ Array newFrom: {newXPoint . newYPoint}.		! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/18/2020 22:48'!AstarPlus: startPoint Point: endpoint Robot: sketchRobot    "comment stating purpose of message"    | x y paths costs maxID found costsVals currentCost currentID currentPath neighbors startPos endPos|    	x := startPoint x.	y := startPoint y.	maxID := 0.	found := false.	startPos := Array newFrom:{x . y}.	startPos := OrderedCollection newFrom:{startPos}.	endPos := Array newFrom:{endpoint x . endpoint y}.	costs := Dictionary new.	costs at: maxID put: 10000.	paths := Dictionary new.	paths at: maxID put: startPos.	(found)whileFalse:[   	 	costsVals := costs values.    	currentCost := costsVals min.    	currentID := costs at: currentCost.    	currentPath := paths at: currentID.        	x := currentPath at: currentPath size at: 1.    	y := currentPath at: currentPath size at: 2.        	neighbors := self getFourNeighbors: x@y Robot: sketchRobot.    	costs at: maxID remove.    	paths at: maxID remove.            	1 to: neighbors size do: [ : index|        	|currentNeighbor cost ID path neighborPoint|                	currentNeighbor := neighbors at: index.        	neighborPoint := Array newFrom: {currentNeighbor location x . currentNeighbor location y}.        	(neighborPoint in: paths values)ifFalse: [             cost := currentNeighbor location x - endpoint x.            cost := cost abs + (currentNeighbor location y - endpoint y) abs.            cost := cost - 1.            ID := maxID + 1.            path := currentPath.            path addLast: neighborPoint.            costs at: ID put: cost.            paths at: ID put: path.            maxID := maxID + 1.            (neighborPoint = endPos)ifTrue: [                 found := true.                ^path.                 ].             ].         ].    ]! !