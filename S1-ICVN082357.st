'From Pharo7.0.4 of 13 August 2019 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)] on 14 February 2020 at 7:27:21.429887 pm'!RobotMind subclass: #MyTeamMind	instanceVariableNames: 'pathToHighestDensityPoint hasHighDensityAreas averageEnergy'	classVariableNames: ''	poolDictionaries: ''	category: 'JRMPC-Phase1-Minds'!!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/14/2020 15:27'!setupOn: sketchRobot	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 This method facilitates initial setup of the mind related to the map parameters.	 It is called once by the competition framework when the mind is instantiated. 	 'sketchRobot' is a copy of the world as seen by the robot's scanners 	"		! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/14/2020 17:26'!determineDirectionForRobot: sketchRobot     "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.     This method is the main entrypoint for competition entries.     It is called each time the game world progresses one step in time.     'sketchRobot' is a copy of the map/robots as seen by a robot's scanners (i.e. no internal state).      Each time step provides a new independent scan 'sketchRobot'.     The mind instance remains constant across steps (i.e. it has memory across time steps).       The actual map/robots remain inaccessible to prevent accidental corruption of the game.    "	| point |	(averageEnergy = -123456)ifTrue: [ "this will only get called once when the robot is setup since the average point value is not known"		| highestDensityPoint densityOfPoint|		highestDensityPoint := self determineHighestDensityPoint: sketchRobot.		densityOfPoint := self determineDensityArroundPoint: highestDensityPoint Robot: sketchRobot. 		(densityOfPoint > (averageEnergy *3))ifTrue: [ 			self getDirectPathToPoint: highestDensityPoint  Robot: sketchRobot.			]		].	"this block of code checks to see if there s another high density point on the board that we can navigate to once we finish getting all the cells in the imediate vicinity"	((pathToHighestDensityPoint isEmpty) and: (directionList size = 1))ifTrue: [ 			| density highestDensityPoint |			density := self determineDensityArroundPoint: (sketchRobot location) Robot: sketchRobot.			(density < (averageEnergy))ifTrue: [ 				| densityOfPoint |				highestDensityPoint := self determineHighestDensityPoint: sketchRobot.				densityOfPoint := self determineDensityArroundPoint: highestDensityPoint Robot: sketchRobot. 				((densityOfPoint > (averageEnergy * 3)) or: (density < 10))ifTrue: [ 					self getDirectPathToPoint: highestDensityPoint Robot: sketchRobot.				 ]			]		 ].					(directionList isEmpty)ifTrue: [ 			(pathToHighestDensityPoint isEmpty)ifFalse: [ 				point := pathToHighestDensityPoint first.				pathToHighestDensityPoint removeAt: 1.			]ifTrue:[				self Dijkstra: sketchRobot. 				]		 ]ifFalse:[			point := directionList first.			directionList removeAt: 1.		].				"Transcript crShow: directionList."	direction := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). 	! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/7/2020 20:33'!direction	"COMPETITION ENTRIES _MUST_NOT_ OVERRIDE THIS METHOD	 This method is how the game later reads the mind's decision	"		"self assert: (direction isKindOf: RobotDirection)."	^ direction! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/7/2020 20:34'!recoverOn: sketchRobot	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 If the mind doesn't complete its step within the designated time, its process is terminated.	 Depending on how you manage your data objects, they may end up corrupted.	 This method allows the mind to reset and continue playing. 	 'sketchRobot' is a copy of the world as seen by the robot's scanners 	"	Transcript crShow: 'PROGRAM TOOK TOO LONG, EXITING'.	self setupOn: sketchRobot! !!MyTeamMind methodsFor: 'initialization' stamp: 'BenTran 2/14/2020 16:14'!initialize 	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 This method is not part of the competition API, but a standard part of Pharo	 called when objects are instatiated."	doesYellowSquareExist := false.	highestPointSquares := OrderedCollection new. 	pathToHighestDensityPoint := OrderedCollection new.	hasHighDensityAreas := true.	averageEnergy := -123456.	depthNN := 3. "number of layers deep that the NN should look at"	depthDijkstra := 5.	directionList := OrderedCollection new.	super initialize! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:33'!getFourNeighbors: point Robot: sketchRobot	| x y right down left up|	x := point x.	y := point y.	right := (sketchRobot map cellAt: (x+1)@y).	down := (sketchRobot map cellAt: x@(y-1)).	left := (sketchRobot map cellAt: (x-1)@y).	up := (sketchRobot map cellAt: x@(y+1)).		^(Array newFrom: {right . down . left . up})! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/14/2020 15:14'!determineDensityArroundPoint: point Robot: sketchRobot	| neighborQueue neighbors totalEnergy x y|.	x := point x.	y := point y.	totalEnergy := 0.	neighborQueue := OrderedCollection new.	"get the first neighbors arround the current point passed in as a parameter"	neighbors := self getFourNeighbors: x@y Robot: sketchRobot.	1 to: (neighbors size) do: [ : neighborIndex|		| neighbor |		neighbor := (neighbors at: neighborIndex) location.		(neighborQueue includes: neighbor)ifFalse: [ 			neighborQueue addLast: neighbor.				]			].	"get the second order neighbors arround those first points"	1 to: (neighborQueue size) do: [ : i|		neighbors := self getFourNeighbors: (neighborQueue at: i) Robot: sketchRobot.		1 to: (neighbors size) do: [ : neighborIndex|			| neighbor |			neighbor := (neighbors at: neighborIndex) location.			(neighborQueue includes: neighbor)ifFalse: [ 				neighborQueue addLast: neighbor.				]			]	].	"once we have a list of all the neighbors arround the given point, sum up the point values for those neighbors"	1 to: (neighborQueue size) do: [ : i|		| neighbor |		neighbor := neighborQueue at: i.		totalEnergy := totalEnergy + ((sketchRobot map cellAt: neighbor) energy)					].	^totalEnergy.	! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:34'!standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows	"this will take a given coordinate and it wrap around the board"	| newXPoint newYPoint |.		newXPoint := ((xPoint \\ columns) abs). "\\ is the same as % in python, coordinate system starts at 1,1 so we need to shift everything by 1"	newYPoint := ((yPoint \\ rows) abs).		(xPoint = 0)ifTrue: [ 		newXPoint := columns 		 ].	(newXPoint = 0)ifTrue: [ 		newXPoint := columns 		 ].	(yPoint = 0)ifTrue: [ 		newYPoint := rows 		 ].	(newYPoint = 0)ifTrue: [ 		newYPoint := rows 		 ].		^ Array newFrom: {newXPoint . newYPoint}.		! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:32'!DetermineRobotMovementFromPoint: point Robot: sketchRobot	| fourNeighbors directionDict|	fourNeighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"	directionDict := Dictionary newFrom: {1 -> RobotEast soleInstance . 2 -> RobotSouth soleInstance . 3 -> RobotWest soleInstance . 4 -> RobotNorth soleInstance .}.	1 to: 4 do: [ 				: neighborIndex|				|neighbor neighborPoint|.				neighbor := (fourNeighbors at: neighborIndex). 				neighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.				(neighborPoint = point)ifTrue: [ 					^(directionDict at: neighborIndex)				].	].	! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:33'!plotPathForNN: sketchRobot	"variable initilization"	| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|	currentItterations := 1.	x := sketchRobot location x.	y := sketchRobot location y.	pathID := 1.	pathEnergies := Dictionary newFrom: {1 -> 0.}.		"paths = {0:[(x, y)]} in python"	firstPath := OrderedCollection new.	firstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"	paths := Dictionary newFrom: {1 -> firstPath.}. 		[currentItterations <= depthNN] whileTrue: [ 		|newPaths|.		newPaths := Dictionary new.		((paths keys sorted) first) to: ((paths keys sorted) last) do: [ 			:key|			|path neighbors|.				path := paths at: key.			"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."			neighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"			1 to: 4 do: [ 				: neighborIndex|				|neighbor neighborPoint|.				neighbor := (neighbors at: neighborIndex). 				neighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.				"Transcript crShow: path.				Transcript crShow: neighborPoint.	"					(path includes: neighborPoint )ifFalse: [					 |newVal newPath|.					newVal := (pathEnergies at: key) + (neighbor energy).					newPath := path copy.					newPath addLast: neighborPoint.					newPaths at: pathID put: newPath.					pathEnergies at: pathID put: newVal.					pathID := (pathID + 1) 															]				ifTrue:[					"Transcript crShow: path.					Transcript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).					Transcript crShow: 'DOES  INCLUDE'."					].				 ]. 			 ].		paths := newPaths copy.		currentItterations := currentItterations + 1.		 ].	bestPathID  := 0.	1 to: ((pathEnergies values) size) do: [ 			:key|			((pathEnergies values max) = (pathEnergies at: key))ifTrue:[				bestPathID := key				].			].	bestPath := paths at: bestPathID.	bestPath removeAt: 1.	directionList := bestPath. "stores best path as a instance variable"				! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:32'!Dijkstra: sketchRobot	"create a new list of all points within the robots scanning radius ----------------------------------------"	| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |	"Transcript crShow: 'Dijkstra HAS BEEN CALLED -----------------------------------------------------'."		scanningRadius := depthDijkstra.	grid := OrderedCollection new.	pointsList := OrderedCollection new.	x := sketchRobot location x.	y := sketchRobot location y.	1 to: scanningRadius * 2 + 1 do: [ :xCord | 		1 to: scanningRadius * 2 + 1 do: [ :yCord | 			| xPoint yPoint point |			xPoint := x - scanningRadius + xCord.			yPoint := y - scanningRadius + yCord.			"this will take a given coordinate and it wrap around the board"			point := self				standardizePoint: xPoint				Integer: yPoint				Integer: sketchRobot map width				Integer: sketchRobot map height.			(grid includes: point) ifFalse: [ "sometimes you get repeats because of the point standardization"					grid addLast: point.					pointsList						addLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy 						] 					] 				].	"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"	"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"	highestPoint := pointsList max.	startingPoint := Array newFrom:{x . y}.	distanceFromStart := Dictionary new.	previousVertex := Dictionary new.	visited := OrderedCollection new.	unVisited := grid copy.	"Transcript crShow: 'STARTING POINT'.	Transcript show: startingPoint."	" set all distances to infinity and initlize previous distance dict with default keys"	1 to: grid size do: [ :i | 		| point |		point := grid at: i.		distanceFromStart at: point put: 1000000.	"1 million, number must be very large because distance from starting point to all other points is unkown at this point"		previousVertex at: point put: (Array newFrom: #(-1 -1)) ].	distanceFromStart at: startingPoint put: 0.			"point visit loop --------------------------------------------------------------------------------------------"	[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |			"find min value in distanceFromStart dict"			minValue := 10000000.	"10 million"			distanceFromStart	keysAndValuesDo: [ :key :value | 					((value < minValue) & ((visited includes: key) not))	ifTrue: [ 							currentPoint := key.							minValue := value 							]						 ].						"iterate through neighbors"			neighbors := self	getFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)	Robot: sketchRobot.			1 to: neighbors size do: [ :i | 				| neighbor neighborPoint |				neighbor := neighbors at: i.				neighborPoint := Array newFrom: {neighbor location x. neighbor location y}.				(grid includes: neighborPoint)ifTrue: [ | distance distanceFromNeighbor |						distance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).						distanceFromNeighbor := distanceFromStart at: neighborPoint.						(distance < distanceFromNeighbor) ifTrue: [ 								distanceFromStart at: neighborPoint put: distance.								previousVertex at: neighborPoint put: currentPoint 								] 							] 						].			visited addLast: currentPoint.			unVisited remove: currentPoint 			].		"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"	shortestPathLength := 1000000.	"1 million"	bestPath := OrderedCollection new.	[ bestPath isEmpty ]		whileTrue: [ 1 to: grid size do: [ :i | 				| point |				point := grid at: i.				((distanceFromStart at: point) < shortestPathLength	& (point = startingPoint) not )ifTrue: [ "point is not equal to starting point"						| path newPoint shouldBreak |						path := OrderedCollection new.						"work backwards from best point to find optimal path"						path addLast: point.	"the point we are trying to is the first item since the list will be reversed"						newPoint := point.	"initialize newPoint w since this will be reassigned in the while loop"						shouldBreak := false.						[ shouldBreak ]whileFalse:[							 newPoint := previousVertex at: newPoint.	"get the previous point and add it to the list"								path addLast: newPoint.								newPoint = startingPoint									ifTrue: [ "if the starting point is equal to current point we found a path"										"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"										path size > scanningRadius											ifTrue: [ 												shortestPathLength := distanceFromStart at: point.												bestPath := path	"this best path is only truly the best once the while loop has exited" 													].										shouldBreak := true 										].								path size > (scanningRadius * 4)									ifTrue: [ shouldBreak := true 										] 									] 								] 							].			"Transcript crShow: 'could not find path'."			scanningRadius := scanningRadius - 1 			].			bestPath removeLast.	bestPath := bestPath reversed.	directionList := bestPath! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/14/2020 17:21'!determineHighestDensityPoint: sketchRobot	| width height maxEnergy maxEnergyPoint totalEnergyOnGrid |. "initilize the variable"   width := sketchRobot map width.   height := sketchRobot map height.	totalEnergyOnGrid := 0 .	maxEnergy := -10000000000. 	maxEnergyPoint := 1@1.   1 to: height do:[:y | "assigns itterator number to y"        1 to: width do:[:x |			| totalEnergy |			totalEnergy := self determineDensityArroundPoint: x@y Robot: sketchRobot.			totalEnergyOnGrid := totalEnergyOnGrid + totalEnergy.			(totalEnergy > maxEnergy)ifTrue: [ 				maxEnergy := totalEnergy.				maxEnergyPoint := x@y				 ]        ]	].	averageEnergy := (totalEnergyOnGrid / (width * height)) asInteger .	^maxEnergyPoint.! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/14/2020 16:57'!getDirectPathToPoint: point Robot: sketchRobot	| currentX currentY targetX targetY|		currentX := sketchRobot location x.		currentY := sketchRobot location y.		targetX := point x.		targetY := point y.		" add x vals to the path"		(targetX < currentX)ifTrue: [ 				currentX to: targetX by: -1 do: [:x|					pathToHighestDensityPoint addLast: (Array newFrom: {x . currentY})		 		]			 ]ifFalse:[			currentX to: targetX do: [:x|				pathToHighestDensityPoint addLast: (Array newFrom: {x . currentY})		 	]		].	" add y vals to the path"	(targetY < currentY)ifTrue: [ 			currentY to: targetY by: -1 do: [:y|				pathToHighestDensityPoint addLast: (Array newFrom: {targetX . y})		 	]		 ] ifFalse: [ 			currentY to: targetY do: [:y|				pathToHighestDensityPoint addLast: (Array newFrom: {targetX . y})		 	]		]! !