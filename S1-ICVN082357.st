'From Pharo7.0.4 of 13 August 2019 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)] on 7 February 2020 at 8:35:27.720197 pm'!RobotMind subclass: #MyTeamMind	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JRMPC-Phase1-Minds'!!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:33'!getFourNeighbors: point Robot: sketchRobot	| x y right down left up|	x := point x.	y := point y.	right := (sketchRobot map cellAt: (x+1)@y).	down := (sketchRobot map cellAt: x@(y-1)).	left := (sketchRobot map cellAt: (x-1)@y).	up := (sketchRobot map cellAt: x@(y+1)).		^(Array newFrom: {right . down . left . up})! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:33'!plotPathForNN: sketchRobot	"variable initilization"	| currentItterations x y paths firstPath pathID pathEnergies bestPathID bestPath|	currentItterations := 1.	x := sketchRobot location x.	y := sketchRobot location y.	pathID := 1.	pathEnergies := Dictionary newFrom: {1 -> 0.}.		"paths = {0:[(x, y)]} in python"	firstPath := OrderedCollection new.	firstPath add: (Array newFrom: {x . y}). "creates a dynamic array at runtime instead of a literal array where the values must be known, the elements of this array need to be separated by a dot"	paths := Dictionary newFrom: {1 -> firstPath.}. 		[currentItterations <= depthNN] whileTrue: [ 		|newPaths|.		newPaths := Dictionary new.		((paths keys sorted) first) to: ((paths keys sorted) last) do: [ 			:key|			|path neighbors|.				path := paths at: key.			"Transcript crShow: (self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot)."			neighbors := self getFourNeighbors: ((path last) at: 1)@((path last) at: 2) Robot: sketchRobot. "retunrs a list formated as follows: [right, down, left, up]"			1 to: 4 do: [ 				: neighborIndex|				|neighbor neighborPoint|.				neighbor := (neighbors at: neighborIndex). 				neighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.				"Transcript crShow: path.				Transcript crShow: neighborPoint.	"					(path includes: neighborPoint )ifFalse: [					 |newVal newPath|.					newVal := (pathEnergies at: key) + (neighbor energy).					newPath := path copy.					newPath addLast: neighborPoint.					newPaths at: pathID put: newPath.					pathEnergies at: pathID put: newVal.					pathID := (pathID + 1) 															]				ifTrue:[					"Transcript crShow: path.					Transcript crShow: (Array newFrom: {(neighbor location x) . (neighbor location y)}).					Transcript crShow: 'DOES  INCLUDE'."					].				 ]. 			 ].		paths := newPaths copy.		currentItterations := currentItterations + 1.		 ].	bestPathID  := 0.	1 to: ((pathEnergies values) size) do: [ 			:key|			((pathEnergies values max) = (pathEnergies at: key))ifTrue:[				bestPathID := key				].			].	bestPath := paths at: bestPathID.	bestPath removeAt: 1.	directionList := bestPath. "stores best path as a instance variable"				! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:32'!DetermineRobotMovementFromPoint: point Robot: sketchRobot	| fourNeighbors directionDict|	fourNeighbors := sketchRobot fourNeighbors. "retunrs a list formated as follows: [right, down, left, up]"	directionDict := Dictionary newFrom: {1 -> RobotEast soleInstance . 2 -> RobotSouth soleInstance . 3 -> RobotWest soleInstance . 4 -> RobotNorth soleInstance .}.	1 to: 4 do: [ 				: neighborIndex|				|neighbor neighborPoint|.				neighbor := (fourNeighbors at: neighborIndex). 				neighborPoint := Array newFrom: {(neighbor location x) . (neighbor location y)}.				(neighborPoint = point)ifTrue: [ 					^(directionDict at: neighborIndex)				].	].	! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:32'!Dijkstra: sketchRobot	"create a new list of all points within the robots scanning radius ----------------------------------------"	| grid pointsList x y highestPoint startingPoint distanceFromStart previousVertex visited unVisited shortestPathLength bestPath scanningRadius |	"Transcript crShow: 'Dijkstra HAS BEEN CALLED -----------------------------------------------------'."		scanningRadius := depthDijkstra.	grid := OrderedCollection new.	pointsList := OrderedCollection new.	x := sketchRobot location x.	y := sketchRobot location y.	1 to: scanningRadius * 2 + 1 do: [ :xCord | 		1 to: scanningRadius * 2 + 1 do: [ :yCord | 			| xPoint yPoint point |			xPoint := x - scanningRadius + xCord.			yPoint := y - scanningRadius + yCord.			"this will take a given coordinate and it wrap around the board"			point := self				standardizePoint: xPoint				Integer: yPoint				Integer: sketchRobot map width				Integer: sketchRobot map height.			(grid includes: point) ifFalse: [ "sometimes you get repeats because of the point standardization"					grid addLast: point.					pointsList						addLast: (sketchRobot map cellAt: (point at: 1) @ (point at: 2)) energy 						] 					] 				].	"initialization stuff -------------------------------------------------------------------------------------------------------------------------------"	"find the highest point since we will be subtracting the value of all other points from this in order to find the cost to move to a square"	highestPoint := pointsList max.	startingPoint := Array newFrom:{x . y}.	distanceFromStart := Dictionary new.	previousVertex := Dictionary new.	visited := OrderedCollection new.	unVisited := grid copy.	"Transcript crShow: 'STARTING POINT'.	Transcript show: startingPoint."	" set all distances to infinity and initlize previous distance dict with default keys"	1 to: grid size do: [ :i | 		| point |		point := grid at: i.		distanceFromStart at: point put: 1000000.	"1 million, number must be very large because distance from starting point to all other points is unkown at this point"		previousVertex at: point put: (Array newFrom: #(-1 -1)) ].	distanceFromStart at: startingPoint put: 0.			"point visit loop --------------------------------------------------------------------------------------------"	[ unVisited size > 0 ]whileTrue: [ | currentPoint minValue neighbors |			"find min value in distanceFromStart dict"			minValue := 10000000.	"10 million"			distanceFromStart	keysAndValuesDo: [ :key :value | 					((value < minValue) & ((visited includes: key) not))	ifTrue: [ 							currentPoint := key.							minValue := value 							]						 ].						"iterate through neighbors"			neighbors := self	getFourNeighbors: (currentPoint at: 1) @ (currentPoint at: 2)	Robot: sketchRobot.			1 to: neighbors size do: [ :i | 				| neighbor neighborPoint |				neighbor := neighbors at: i.				neighborPoint := Array newFrom: {neighbor location x. neighbor location y}.				(grid includes: neighborPoint)ifTrue: [ | distance distanceFromNeighbor |						distance := (distanceFromStart at: currentPoint) + (highestPoint - neighbor energy).						distanceFromNeighbor := distanceFromStart at: neighborPoint.						(distance < distanceFromNeighbor) ifTrue: [ 								distanceFromStart at: neighborPoint put: distance.								previousVertex at: neighborPoint put: currentPoint 								] 							] 						].			visited addLast: currentPoint.			unVisited remove: currentPoint 			].		"while loop has exited meaning that the shortest path has been found ---------------------------------------------------------------------------"	shortestPathLength := 1000000.	"1 million"	bestPath := OrderedCollection new.	[ bestPath isEmpty ]		whileTrue: [ 1 to: grid size do: [ :i | 				| point |				point := grid at: i.				((distanceFromStart at: point) < shortestPathLength	& (point = startingPoint) not )ifTrue: [ "point is not equal to starting point"						| path newPoint shouldBreak |						path := OrderedCollection new.						"work backwards from best point to find optimal path"						path addLast: point.	"the point we are trying to is the first item since the list will be reversed"						newPoint := point.	"initialize newPoint w since this will be reassigned in the while loop"						shouldBreak := false.						[ shouldBreak ]whileFalse:[							 newPoint := previousVertex at: newPoint.	"get the previous point and add it to the list"								path addLast: newPoint.								newPoint = startingPoint									ifTrue: [ "if the starting point is equal to current point we found a path"										"sometimes the newPoint will be equal to starting point but less than scanningRadius so we need to break"										path size > scanningRadius											ifTrue: [ 												shortestPathLength := distanceFromStart at: point.												bestPath := path	"this best path is only truly the best once the while loop has exited" 													].										shouldBreak := true 										].								path size > (scanningRadius * 4)									ifTrue: [ shouldBreak := true 										] 									] 								] 							].			"Transcript crShow: 'could not find path'."			scanningRadius := scanningRadius - 1 			].			bestPath removeLast.	bestPath := bestPath reversed.	directionList := bestPath! !!MyTeamMind methodsFor: 'as yet unclassified' stamp: 'BenTran 2/7/2020 20:34'!standardizePoint: xPoint Integer: yPoint Integer: columns Integer: rows	"this will take a given coordinate and it wrap around the board"	| newXPoint newYPoint |.		newXPoint := ((xPoint \\ columns) abs). "\\ is the same as % in python, coordinate system starts at 1,1 so we need to shift everything by 1"	newYPoint := ((yPoint \\ rows) abs).		(xPoint = 0)ifTrue: [ 		newXPoint := columns 		 ].	(newXPoint = 0)ifTrue: [ 		newXPoint := columns 		 ].	(yPoint = 0)ifTrue: [ 		newYPoint := rows 		 ].	(newYPoint = 0)ifTrue: [ 		newYPoint := rows 		 ].		^ Array newFrom: {newXPoint . newYPoint}.		! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/7/2020 20:34'!setupOn: sketchRobot	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 This method facilitates initial setup of the mind related to the map parameters.	 It is called once by the competition framework when the mind is instantiated. 	 'sketchRobot' is a copy of the world as seen by the robot's scanners 	"	"chekc for yellow square"	|width height itterator|. "initilize the variable"   width := sketchRobot map width.   height := sketchRobot map height.	itterator := 1.   1 to: height do:[ "for loop"   		:y | "assigns itterator number to i"        1 to: width do:[       	:x |			|energyValue|.			energyValue := ((sketchRobot map cellAt: x@y) energy).         (energyValue> 90) "the x@y signifies a point object ex: (1,1) or (5,99)"         ifTrue: [          	highestPointSquares add: energyValue.			itterator := itterator + 1.         	doesYellowSquareExist := true.         ].		].	].			! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/7/2020 20:32'!determineDirectionForRobot: sketchRobot     "COMPETITION ENTRIES _MUST_ OVERRIDE THIS METHOD.     This method is the main entrypoint for competition entries.     It is called each time the game world progresses one step in time.     'sketchRobot' is a copy of the map/robots as seen by a robot's scanners (i.e. no internal state).      Each time step provides a new independent scan 'sketchRobot'.     The mind instance remains constant across steps (i.e. it has memory across time steps).       The actual map/robots remain inaccessible to prevent accidental corruption of the game.    "	| point |	(directionList isEmpty)ifTrue: [ 		self Dijkstra: sketchRobot. "This is a method call for plotPathForNN, in python this would be the same as self.plotPathForNN(sketchRobot)" 		 ].	point := directionList first.	"Transcript crShow: directionList."	direction := (self DetermineRobotMovementFromPoint: point Robot: sketchRobot). 	directionList removeAt: 1.	! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/7/2020 20:33'!direction	"COMPETITION ENTRIES _MUST_NOT_ OVERRIDE THIS METHOD	 This method is how the game later reads the mind's decision	"		"self assert: (direction isKindOf: RobotDirection)."	^ direction! !!MyTeamMind methodsFor: 'running' stamp: 'BenTran 2/7/2020 20:34'!recoverOn: sketchRobot	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 If the mind doesn't complete its step within the designated time, its process is terminated.	 Depending on how you manage your data objects, they may end up corrupted.	 This method allows the mind to reset and continue playing. 	 'sketchRobot' is a copy of the world as seen by the robot's scanners 	"	Transcript crShow: 'PROGRAM TOOK TOO LONG, EXITING'.	self setupOn: sketchRobot! !!MyTeamMind methodsFor: 'initialization' stamp: 'BenTran 2/7/2020 20:33'!initialize 	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 This method is not part of the competition API, but a standard part of Pharo	 called when objects are instatiated."	doesYellowSquareExist := false.	highestPointSquares := OrderedCollection new. 	depthNN := 3. "number of layers deep that the NN should look at"	depthDijkstra := 5.	currentX := 0.	currentY := 0.	directionList := OrderedCollection new.	super initialize! !